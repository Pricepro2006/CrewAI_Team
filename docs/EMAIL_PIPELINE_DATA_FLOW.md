# Email Pipeline Data Flow & UI Integration

## Overview

The email pipeline operates as an autonomous backend service that continuously processes emails and generates actionable data. The UI simply presents this pre-processed information.

## Data Flow Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           EMAIL SOURCES                                  │
│                         (24 Mailboxes)                                  │
└─────────────────────────────────┬───────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                      BACKEND PIPELINE (24/7)                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. Email Polling (every 5 min) ──► 2. Three-Phase Analysis           │
│                                           │                             │
│                                           ▼                             │
│                                     3. Task Generation                  │
│                                           │                             │
│                                           ▼                             │
│                                     4. Database Storage                 │
│                                           │                             │
│     ┌─────────────────────────────────────┼─────────────────────┐      │
│     │                                     │                     │      │
│     ▼                                     ▼                     ▼      │
│  5. Metric Aggregation            6. SLA Monitoring      7. Events     │
│     (every 15 min)                  (every 10 min)         (real-time) │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
                                  │
                    ┌─────────────┼─────────────┐
                    │             │             │
                    ▼             ▼             ▼
                REST API    WebSocket      Cached Data
                    │             │             │
                    └─────────────┼─────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                               UI LAYER                                   │
│                                                                         │
│  • Executive Dashboard    - Displays cached metrics                     │
│  • Workflow Board        - Shows pre-processed tasks                   │
│  • Task Manager          - Lists actionable items                      │
│  • Real-time Updates     - Receives WebSocket events                   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

## Key Data Structures

### 1. Workflow Task (Generated by Backend)

```typescript
{
  task_id: "550e8400-e29b-41d4-a716-446655440000",
  email_id: "email_123456",

  // Classification (Backend Determined)
  workflow_category: "Quote Processing",
  workflow_state: "IN_PROGRESS",
  task_status: "YELLOW",  // Red/Yellow/Green

  // Task Details (Backend Generated)
  title: "Quote Request - ABC Corp - $50,000",
  description: "15 servers HP ProLiant DL380 Gen10",
  priority: "HIGH",

  // Ownership (Backend Assigned)
  current_owner: "John Smith",
  owner_email: "john.smith@tdsynnex.com",

  // Timing (Backend Calculated)
  created_at: "2025-01-31T10:30:00Z",
  sla_deadline: "2025-02-01T10:30:00Z",

  // Business Data (Backend Extracted)
  entities: {
    po_numbers: ["12345678"],
    quote_numbers: ["Q-98765"],
    dollar_value: 50000
  }
}
```

### 2. Executive Metrics (Backend Aggregated)

```typescript
{
  total_tasks: 1547,
  red_tasks: 47,           // Critical
  yellow_tasks: 312,       // In Progress
  green_tasks: 1023,       // On Track
  completed_tasks: 165,

  revenue_at_risk: 1250000,  // Sum of RED task values
  sla_violations: 12,

  bottleneck: "Vendor Pricing Delays",
  efficiency_score: 0.87,

  lastUpdated: "2025-01-31T10:45:00Z"
}
```

### 3. Real-time Events (Backend Emitted)

```typescript
// New Task Created
{
  event: "workflow:task:created",
  data: {
    task: { /* full task object */ },
    impact: "HIGH",
    category: "Quote Processing"
  }
}

// Status Changed
{
  event: "workflow:status:changed",
  data: {
    taskId: "550e8400...",
    oldStatus: "GREEN",
    newStatus: "YELLOW",
    reason: "SLA approaching"
  }
}

// SLA Warning
{
  event: "workflow:sla:warning",
  data: {
    taskId: "550e8400...",
    hoursRemaining: 4,
    severity: "CRITICAL"
  }
}

// Metrics Updated
{
  event: "workflow:metrics:updated",
  data: { /* full metrics object */ }
}
```

## UI Integration Points

### 1. Initial Load

```typescript
// UI Component
async function loadDashboard() {
  // Fetch pre-calculated metrics
  const metrics = await api.get("/api/workflow/metrics");

  // Fetch active tasks
  const tasks = await api.get("/api/workflow/tasks?status=active");

  // Display immediately (no processing needed)
  setDashboardData({ metrics, tasks });
}
```

### 2. Real-time Updates

```typescript
// WebSocket Connection
const ws = new WebSocket("ws://localhost:3002");

ws.on("message", (data) => {
  const { event, data: payload } = JSON.parse(data);

  switch (event) {
    case "workflow:task:created":
      addTaskToList(payload.task);
      updateMetricCount("total_tasks", +1);
      break;

    case "workflow:status:changed":
      updateTaskStatus(payload.taskId, payload.newStatus);
      if (payload.newStatus === "RED") {
        showCriticalAlert(payload.taskId);
      }
      break;

    case "workflow:sla:warning":
      highlightTask(payload.taskId);
      showCountdown(payload.hoursRemaining);
      break;

    case "workflow:metrics:updated":
      updateDashboardMetrics(payload);
      break;
  }
});
```

### 3. User Actions

```typescript
// UI triggers backend operations
async function reassignTask(taskId: string, newOwner: string) {
  // UI sends command
  await api.put(`/api/workflow/tasks/${taskId}`, {
    current_owner: newOwner,
  });

  // Backend handles:
  // - Database update
  // - Status history logging
  // - Notification to new owner
  // - WebSocket event broadcast

  // UI receives update via WebSocket
}

async function completeTask(taskId: string) {
  await api.put(`/api/workflow/tasks/${taskId}`, {
    task_status: "COMPLETED",
    completion_date: new Date(),
  });

  // Backend updates metrics, sends events
}
```

## Performance Benefits

### 1. **Pre-calculated Metrics**

- Executive dashboard loads instantly
- No complex queries from UI
- Metrics cached and updated every 15 minutes

### 2. **Async Processing**

- Emails processed in background
- UI never waits for analysis
- Three-phase analysis happens server-side

### 3. **Push Updates**

- WebSocket delivers changes
- No polling required
- Instant UI updates

### 4. **Scalable Architecture**

- Add more pipeline workers as needed
- UI unaffected by email volume
- Horizontal scaling possible

## Example Scenarios

### Scenario 1: High-Priority Email Arrives

```
1. Email arrives: "URGENT: Quote needed for $100k order"
2. Pipeline picks up (within 5 min)
3. Phase 1: Detects "Quote Processing", "RED" status
4. Phase 2: Assigns to "Sales Team Lead"
5. Phase 3: Flags expansion opportunity
6. Task created with 4-hour SLA
7. WebSocket broadcasts: "workflow:task:created"
8. UI shows red notification instantly
9. Dashboard metrics update automatically
```

### Scenario 2: SLA About to Expire

```
1. SLA Monitor runs (every 10 min)
2. Finds task with 2 hours remaining
3. Broadcasts: "workflow:sla:warning"
4. UI highlights task in yellow
5. Shows countdown timer
6. If SLA expires, status → RED
7. Critical alert sent to manager
8. Executive metrics update
```

### Scenario 3: Bulk Email Processing

```
1. 500 emails arrive overnight
2. Pipeline processes in batches
3. Creates 150 new tasks
4. Updates various statuses
5. Aggregates new metrics
6. Single "workflow:metrics:updated" event
7. UI refreshes dashboard once
8. No performance impact on users
```

## Implementation Checklist

### Backend Pipeline ✅

- [x] Email polling service
- [x] Three-phase analysis integration
- [x] Task generation logic
- [x] Database schema
- [x] Metric aggregation
- [x] SLA monitoring
- [x] WebSocket events
- [x] Background job scheduling

### UI Integration 🚧

- [ ] WebSocket client setup
- [ ] Real-time event handlers
- [ ] Dashboard components
- [ ] Task list with live updates
- [ ] Metric visualization
- [ ] Action buttons (reassign, complete)
- [ ] SLA countdown timers
- [ ] Critical alerts

### Deployment 📋

- [ ] Backend service deployment
- [ ] Database migrations
- [ ] WebSocket infrastructure
- [ ] Monitoring setup
- [ ] Performance testing
- [ ] Load balancing
- [ ] Backup strategies

This architecture ensures the email pipeline operates independently, continuously generating actionable insights that the UI presents in real-time without any processing overhead.
