{"version":3,"file":"trpc-Bf2ShbKM.js","sources":["../../../node_modules/@tanstack/query-core/build/lib/subscribable.mjs","../../../node_modules/@tanstack/query-core/build/lib/utils.mjs","../../../node_modules/@tanstack/query-core/build/lib/focusManager.mjs","../../../node_modules/@tanstack/query-core/build/lib/onlineManager.mjs","../../../node_modules/@tanstack/query-core/build/lib/retryer.mjs","../../../node_modules/@tanstack/query-core/build/lib/logger.mjs","../../../node_modules/@tanstack/query-core/build/lib/notifyManager.mjs","../../../node_modules/@tanstack/query-core/build/lib/removable.mjs","../../../node_modules/@tanstack/query-core/build/lib/query.mjs","../../../node_modules/@tanstack/query-core/build/lib/queryCache.mjs","../../../node_modules/@tanstack/query-core/build/lib/mutation.mjs","../../../node_modules/@tanstack/query-core/build/lib/mutationCache.mjs","../../../node_modules/@tanstack/query-core/build/lib/infiniteQueryBehavior.mjs","../../../node_modules/@tanstack/query-core/build/lib/queryClient.mjs","../../../node_modules/@tanstack/query-core/build/lib/queryObserver.mjs","../../../node_modules/@tanstack/query-core/build/lib/queriesObserver.mjs","../../../node_modules/@tanstack/query-core/build/lib/infiniteQueryObserver.mjs","../../../node_modules/@tanstack/query-core/build/lib/mutationObserver.mjs","../../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js","../../../node_modules/use-sync-external-store/shim/index.js","../../../node_modules/@tanstack/react-query/build/lib/useSyncExternalStore.mjs","../../../node_modules/@tanstack/react-query/build/lib/QueryClientProvider.mjs","../../../node_modules/@tanstack/react-query/build/lib/isRestoring.mjs","../../../node_modules/@tanstack/react-query/build/lib/QueryErrorResetBoundary.mjs","../../../node_modules/@tanstack/react-query/build/lib/utils.mjs","../../../node_modules/@tanstack/react-query/build/lib/errorBoundaryUtils.mjs","../../../node_modules/@tanstack/react-query/build/lib/suspense.mjs","../../../node_modules/@tanstack/react-query/build/lib/useQueries.mjs","../../../node_modules/@tanstack/react-query/build/lib/useBaseQuery.mjs","../../../node_modules/@tanstack/react-query/build/lib/useQuery.mjs","../../../node_modules/@tanstack/react-query/build/lib/useMutation.mjs","../../../node_modules/@tanstack/react-query/build/lib/useInfiniteQuery.mjs","../../../node_modules/@trpc/server/dist/observable-ade1bad8.mjs","../../../node_modules/@trpc/server/dist/observable/index.mjs","../../../node_modules/@trpc/client/dist/splitLink-4c75f7be.mjs","../../../node_modules/@trpc/server/dist/codes-c924c3db.mjs","../../../node_modules/@trpc/server/dist/index-f91d720c.mjs","../../../node_modules/@trpc/server/dist/getCauseFromUnknown-2d66414a.mjs","../../../node_modules/@trpc/client/dist/transformResult-ace864b8.mjs","../../../node_modules/@trpc/client/dist/TRPCClientError-38f9a32a.mjs","../../../node_modules/@trpc/client/dist/httpUtils-b9d0cb48.mjs","../../../node_modules/@trpc/client/dist/httpBatchLink-d0f9eac9.mjs","../../../node_modules/@trpc/client/dist/links/wsLink.mjs","../../../node_modules/@trpc/client/dist/index.mjs","../../../node_modules/@trpc/react-query/dist/getArrayQueryKey-86134f8b.mjs","../../../node_modules/@trpc/react-query/dist/createHooksInternal-063195fc.mjs","../../../node_modules/@trpc/react-query/dist/index.mjs"],"sourcesContent":["class Subscribable {\n  constructor() {\n    this.listeners = new Set();\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  subscribe(listener) {\n    const identity = {\n      listener\n    };\n    this.listeners.add(identity);\n    this.onSubscribe();\n    return () => {\n      this.listeners.delete(identity);\n      this.onUnsubscribe();\n    };\n  }\n\n  hasListeners() {\n    return this.listeners.size > 0;\n  }\n\n  onSubscribe() {// Do nothing\n  }\n\n  onUnsubscribe() {// Do nothing\n  }\n\n}\n\nexport { Subscribable };\n//# sourceMappingURL=subscribable.mjs.map\n","// TYPES\n// UTILS\nconst isServer = typeof window === 'undefined' || 'Deno' in window;\nfunction noop() {\n  return undefined;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\nfunction difference(array1, array2) {\n  return array1.filter(x => !array2.includes(x));\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3,\n      queryKey: arg1,\n      queryFn: arg2\n    };\n  }\n\n  return { ...arg2,\n    queryKey: arg1\n  };\n}\nfunction parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3,\n        mutationKey: arg1,\n        mutationFn: arg2\n      };\n    }\n\n    return { ...arg2,\n      mutationKey: arg1\n    };\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2,\n      mutationFn: arg1\n    };\n  }\n\n  return { ...arg1\n  };\n}\nfunction parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    queryKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction parseMutationFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    mutationKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive();\n\n    if (type === 'active' && !isActive) {\n      return false;\n    }\n\n    if (type === 'inactive' && isActive) {\n      return false;\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n\n  if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    fetching,\n    predicate,\n    mutationKey\n  } = filters;\n\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\n\nfunction hashQueryKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\nfunction partialMatchKey(a, b) {\n  return partialDeepEqual(a, b);\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  const ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  const prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isQueryKey(value) {\n  return Array.isArray(value);\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\nfunction sleep(timeout) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\nfunction scheduleMicrotask(callback) {\n  sleep(0).then(callback);\n}\nfunction getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n\n  return;\n}\nfunction replaceData(prevData, data, options) {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {\n    return prevData;\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data);\n  }\n\n  return data;\n}\n\nexport { difference, functionalUpdate, getAbortController, hashQueryKey, hashQueryKeyByOptions, isError, isPlainArray, isPlainObject, isQueryKey, isServer, isValidTimeout, matchMutation, matchQuery, noop, parseFilterArgs, parseMutationArgs, parseMutationFilterArgs, parseQueryArgs, partialDeepEqual, partialMatchKey, replaceAt, replaceData, replaceEqualDeep, scheduleMicrotask, shallowEqualObjects, sleep, timeUntilStale };\n//# sourceMappingURL=utils.mjs.map\n","import { Subscribable } from './subscribable.mjs';\nimport { isServer } from './utils.mjs';\n\nclass FocusManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onFocus => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus(); // Listen to visibillitychange and focus\n\n\n        window.addEventListener('visibilitychange', listener, false);\n        window.addEventListener('focus', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener);\n          window.removeEventListener('focus', listener);\n        };\n      }\n\n      return;\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(focused => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n\n  setFocused(focused) {\n    const changed = this.focused !== focused;\n\n    if (changed) {\n      this.focused = focused;\n      this.onFocus();\n    }\n  }\n\n  onFocus() {\n    this.listeners.forEach(({\n      listener\n    }) => {\n      listener();\n    });\n  }\n\n  isFocused() {\n    if (typeof this.focused === 'boolean') {\n      return this.focused;\n    } // document global can be unavailable in react native\n\n\n    if (typeof document === 'undefined') {\n      return true;\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(document.visibilityState);\n  }\n\n}\nconst focusManager = new FocusManager();\n\nexport { FocusManager, focusManager };\n//# sourceMappingURL=focusManager.mjs.map\n","import { Subscribable } from './subscribable.mjs';\nimport { isServer } from './utils.mjs';\n\nconst onlineEvents = ['online', 'offline'];\nclass OnlineManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onOnline => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline(); // Listen to online\n\n\n        onlineEvents.forEach(event => {\n          window.addEventListener(event, listener, false);\n        });\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          onlineEvents.forEach(event => {\n            window.removeEventListener(event, listener);\n          });\n        };\n      }\n\n      return;\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(online => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online);\n      } else {\n        this.onOnline();\n      }\n    });\n  }\n\n  setOnline(online) {\n    const changed = this.online !== online;\n\n    if (changed) {\n      this.online = online;\n      this.onOnline();\n    }\n  }\n\n  onOnline() {\n    this.listeners.forEach(({\n      listener\n    }) => {\n      listener();\n    });\n  }\n\n  isOnline() {\n    if (typeof this.online === 'boolean') {\n      return this.online;\n    }\n\n    if (typeof navigator === 'undefined' || typeof navigator.onLine === 'undefined') {\n      return true;\n    }\n\n    return navigator.onLine;\n  }\n\n}\nconst onlineManager = new OnlineManager();\n\nexport { OnlineManager, onlineManager };\n//# sourceMappingURL=onlineManager.mjs.map\n","import { focusManager } from './focusManager.mjs';\nimport { onlineManager } from './onlineManager.mjs';\nimport { sleep } from './utils.mjs';\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * 2 ** failureCount, 30000);\n}\n\nfunction canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\nclass CancelledError {\n  constructor(options) {\n    this.revert = options == null ? void 0 : options.revert;\n    this.silent = options == null ? void 0 : options.silent;\n  }\n\n}\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        const canContinue = isResolved || !shouldPause();\n\n        if (canContinue) {\n          continueResolve(value);\n        }\n\n        return canContinue;\n      };\n\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(() => {\n      continueFn = undefined;\n\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n\n    let promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n\n        return;\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      const didContinue = continueFn == null ? void 0 : continueFn();\n      return didContinue ? promise : Promise.resolve();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}\n\nexport { CancelledError, canFetch, createRetryer, isCancelledError };\n//# sourceMappingURL=retryer.mjs.map\n","const defaultLogger = console;\n\nexport { defaultLogger };\n//# sourceMappingURL=logger.mjs.map\n","import { scheduleMicrotask } from './utils.mjs';\n\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n\n  let notifyFn = callback => {\n    callback();\n  };\n\n  let batchNotifyFn = callback => {\n    callback();\n  };\n\n  const batch = callback => {\n    let result;\n    transactions++;\n\n    try {\n      result = callback();\n    } finally {\n      transactions--;\n\n      if (!transactions) {\n        flush();\n      }\n    }\n\n    return result;\n  };\n\n  const schedule = callback => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n\n\n  const batchCalls = callback => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args);\n      });\n    };\n  };\n\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach(callback => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n\n\n  const setNotifyFunction = fn => {\n    notifyFn = fn;\n  };\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n\n\n  const setBatchNotifyFunction = fn => {\n    batchNotifyFn = fn;\n  };\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction\n  };\n} // SINGLETON\n\nconst notifyManager = createNotifyManager();\n\nexport { createNotifyManager, notifyManager };\n//# sourceMappingURL=notifyManager.mjs.map\n","import { isValidTimeout, isServer } from './utils.mjs';\n\nclass Removable {\n  destroy() {\n    this.clearGcTimeout();\n  }\n\n  scheduleGc() {\n    this.clearGcTimeout();\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.cacheTime);\n    }\n  }\n\n  updateCacheTime(newCacheTime) {\n    // Default to 5 minutes (Infinity for server-side) if no cache time is set\n    this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1000);\n  }\n\n  clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout);\n      this.gcTimeout = undefined;\n    }\n  }\n\n}\n\nexport { Removable };\n//# sourceMappingURL=removable.mjs.map\n","import { replaceData, noop, timeUntilStale, getAbortController } from './utils.mjs';\nimport { defaultLogger } from './logger.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { createRetryer, isCancelledError, canFetch } from './retryer.mjs';\nimport { Removable } from './removable.mjs';\n\n// CLASS\nclass Query extends Removable {\n  constructor(config) {\n    super();\n    this.abortSignalConsumed = false;\n    this.defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.cache = config.cache;\n    this.logger = config.logger || defaultLogger;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.initialState = config.state || getDefaultState(this.options);\n    this.state = this.initialState;\n    this.scheduleGc();\n  }\n\n  get meta() {\n    return this.options.meta;\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this);\n    }\n  }\n\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n      manual: options == null ? void 0 : options.manual\n    });\n    return data;\n  }\n\n  setState(state, setStateOptions) {\n    this.dispatch({\n      type: 'setState',\n      state,\n      setStateOptions\n    });\n  }\n\n  cancel(options) {\n    var _this$retryer;\n\n    const promise = this.promise;\n    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n\n  reset() {\n    this.destroy();\n    this.setState(this.initialState);\n  }\n\n  isActive() {\n    return this.observers.some(observer => observer.options.enabled !== false);\n  }\n\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(observer => observer.getCurrentResult().isStale);\n  }\n\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n\n  onFocus() {\n    var _this$retryer2;\n\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n  }\n\n  onOnline() {\n    var _this$retryer3;\n\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n  }\n\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer); // Stop the query from being garbage collected\n\n      this.clearGcTimeout();\n      this.cache.notify({\n        type: 'observerAdded',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter(x => x !== observer);\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.retryer.cancelRetry();\n          }\n        }\n\n        this.scheduleGc();\n      }\n\n      this.cache.notify({\n        type: 'observerRemoved',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  getObserversCount() {\n    return this.observers.length;\n  }\n\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: 'invalidate'\n      });\n    }\n  }\n\n  fetch(options, fetchOptions) {\n    var _this$options$behavio, _context$fetchOptions;\n\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({\n          silent: true\n        });\n      } else if (this.promise) {\n        var _this$retryer4;\n\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n        return this.promise;\n      }\n    } // Update config if passed, otherwise the config from the last execution is used\n\n\n    if (options) {\n      this.setOptions(options);\n    } // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n\n\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n      }\n    }\n\n    const abortController = getAbortController(); // Create query function context\n\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta\n    }; // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n\n    const addSignalProperty = object => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true;\n            return abortController.signal;\n          }\n\n          return undefined;\n        }\n      });\n    };\n\n    addSignalProperty(queryFnContext); // Create fetch function\n\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject(\"Missing queryFn for queryKey '\" + this.options.queryHash + \"'\");\n      }\n\n      this.abortSignalConsumed = false;\n      return this.options.queryFn(queryFnContext);\n    }; // Trigger behavior hook\n\n\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn\n    };\n    addSignalProperty(context);\n    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n    this.revertState = this.state; // Set to fetching state if not already in it\n\n    if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n\n      this.dispatch({\n        type: 'fetch',\n        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n\n    const onError = error => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n\n      if (!isCancelledError(error)) {\n        var _this$cache$config$on, _this$cache$config, _this$cache$config$on2, _this$cache$config2;\n\n        // Notify cache callback\n        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);\n        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, this.state.data, error, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc();\n      }\n\n      this.isFetchingOptimistic = false;\n    }; // Try to fetch the data\n\n\n    this.retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n      onSuccess: data => {\n        var _this$cache$config$on3, _this$cache$config3, _this$cache$config$on4, _this$cache$config4;\n\n        if (typeof data === 'undefined') {\n          if (process.env.NODE_ENV !== 'production') {\n            this.logger.error(\"Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: \" + this.queryHash);\n          }\n\n          onError(new Error(this.queryHash + \" data is undefined\"));\n          return;\n        }\n\n        this.setData(data); // Notify cache callback\n\n        (_this$cache$config$on3 = (_this$cache$config3 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on3.call(_this$cache$config3, data, this);\n        (_this$cache$config$on4 = (_this$cache$config4 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on4.call(_this$cache$config4, data, this.state.error, this);\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc();\n        }\n\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.dispatch({\n          type: 'failed',\n          failureCount,\n          error\n        });\n      },\n      onPause: () => {\n        this.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: () => {\n        this.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.promise = this.retryer.promise;\n    return this.promise;\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      var _action$meta, _action$dataUpdatedAt;\n\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n\n        case 'pause':\n          return { ...state,\n            fetchStatus: 'paused'\n          };\n\n        case 'continue':\n          return { ...state,\n            fetchStatus: 'fetching'\n          };\n\n        case 'fetch':\n          return { ...state,\n            fetchFailureCount: 0,\n            fetchFailureReason: null,\n            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n            fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            })\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            })\n          };\n\n        case 'error':\n          const error = action.error;\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState,\n              fetchStatus: 'idle'\n            };\n          }\n\n          return { ...state,\n            error: error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error'\n          };\n\n        case 'invalidate':\n          return { ...state,\n            isInvalidated: true\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action);\n      });\n      this.cache.notify({\n        query: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\n\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  const hasData = typeof data !== 'undefined';\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n}\n\nexport { Query };\n//# sourceMappingURL=query.mjs.map\n","import { hashQueryKeyByOptions, parseFilterArgs, matchQuery } from './utils.mjs';\nimport { Query } from './query.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\n// CLASS\nclass QueryCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.queries = [];\n    this.queriesMap = {};\n  }\n\n  build(client, options, state) {\n    var _options$queryHash;\n\n    const queryKey = options.queryKey;\n    const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey)\n      });\n      this.add(query);\n    }\n\n    return query;\n  }\n\n  add(query) {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query;\n      this.queries.push(query);\n      this.notify({\n        type: 'added',\n        query\n      });\n    }\n  }\n\n  remove(query) {\n    const queryInMap = this.queriesMap[query.queryHash];\n\n    if (queryInMap) {\n      query.destroy();\n      this.queries = this.queries.filter(x => x !== query);\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash];\n      }\n\n      this.notify({\n        type: 'removed',\n        query\n      });\n    }\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        this.remove(query);\n      });\n    });\n  }\n\n  get(queryHash) {\n    return this.queriesMap[queryHash];\n  }\n\n  getAll() {\n    return this.queries;\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  find(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.queries.find(query => matchQuery(filters, query));\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  findAll(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    return Object.keys(filters).length > 0 ? this.queries.filter(query => matchQuery(filters, query)) : this.queries;\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({\n        listener\n      }) => {\n        listener(event);\n      });\n    });\n  }\n\n  onFocus() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onFocus();\n      });\n    });\n  }\n\n  onOnline() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onOnline();\n      });\n    });\n  }\n\n}\n\nexport { QueryCache };\n//# sourceMappingURL=queryCache.mjs.map\n","import { defaultLogger } from './logger.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Removable } from './removable.mjs';\nimport { createRetryer, canFetch } from './retryer.mjs';\n\n// CLASS\nclass Mutation extends Removable {\n  constructor(config) {\n    super();\n    this.defaultOptions = config.defaultOptions;\n    this.mutationId = config.mutationId;\n    this.mutationCache = config.mutationCache;\n    this.logger = config.logger || defaultLogger;\n    this.observers = [];\n    this.state = config.state || getDefaultState();\n    this.setOptions(config.options);\n    this.scheduleGc();\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  get meta() {\n    return this.options.meta;\n  }\n\n  setState(state) {\n    this.dispatch({\n      type: 'setState',\n      state\n    });\n  }\n\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer); // Stop the mutation from being garbage collected\n\n      this.clearGcTimeout();\n      this.mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    this.observers = this.observers.filter(x => x !== observer);\n    this.scheduleGc();\n    this.mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer\n    });\n  }\n\n  optionalRemove() {\n    if (!this.observers.length) {\n      if (this.state.status === 'loading') {\n        this.scheduleGc();\n      } else {\n        this.mutationCache.remove(this);\n      }\n    }\n  }\n\n  continue() {\n    var _this$retryer$continu, _this$retryer;\n\n    return (_this$retryer$continu = (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.continue()) != null ? _this$retryer$continu : this.execute();\n  }\n\n  async execute() {\n    const executeMutation = () => {\n      var _this$options$retry;\n\n      this.retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject('No mutationFn found');\n          }\n\n          return this.options.mutationFn(this.state.variables);\n        },\n        onFail: (failureCount, error) => {\n          this.dispatch({\n            type: 'failed',\n            failureCount,\n            error\n          });\n        },\n        onPause: () => {\n          this.dispatch({\n            type: 'pause'\n          });\n        },\n        onContinue: () => {\n          this.dispatch({\n            type: 'continue'\n          });\n        },\n        retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode\n      });\n      return this.retryer.promise;\n    };\n\n    const restored = this.state.status === 'loading';\n\n    try {\n      var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onSettl, _this$options3;\n\n      if (!restored) {\n        var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;\n\n        this.dispatch({\n          type: 'loading',\n          variables: this.options.variables\n        }); // Notify cache callback\n\n        await ((_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this));\n        const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));\n\n        if (context !== this.state.context) {\n          this.dispatch({\n            type: 'loading',\n            context,\n            variables: this.state.variables\n          });\n        }\n      }\n\n      const data = await executeMutation(); // Notify cache callback\n\n      await ((_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this));\n      await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context)); // Notify cache callback\n\n      await ((_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, data, null, this.state.variables, this.state.context, this));\n      await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));\n      this.dispatch({\n        type: 'success',\n        data\n      });\n      return data;\n    } catch (error) {\n      try {\n        var _this$mutationCache$c7, _this$mutationCache$c8, _this$options$onError, _this$options4, _this$mutationCache$c9, _this$mutationCache$c10, _this$options$onSettl2, _this$options5;\n\n        // Notify cache callback\n        await ((_this$mutationCache$c7 = (_this$mutationCache$c8 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c7.call(_this$mutationCache$c8, error, this.state.variables, this.state.context, this));\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n\n        await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context)); // Notify cache callback\n\n        await ((_this$mutationCache$c9 = (_this$mutationCache$c10 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c9.call(_this$mutationCache$c10, undefined, error, this.state.variables, this.state.context, this));\n        await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, undefined, error, this.state.variables, this.state.context));\n        throw error;\n      } finally {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n    }\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error\n          };\n\n        case 'pause':\n          return { ...state,\n            isPaused: true\n          };\n\n        case 'continue':\n          return { ...state,\n            isPaused: false\n          };\n\n        case 'loading':\n          return { ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'loading',\n            variables: action.variables\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false\n          };\n\n        case 'error':\n          return { ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error'\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onMutationUpdate(action);\n      });\n      this.mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\nfunction getDefaultState() {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined\n  };\n}\n\nexport { Mutation, getDefaultState };\n//# sourceMappingURL=mutation.mjs.map\n","import { notifyManager } from './notifyManager.mjs';\nimport { Mutation } from './mutation.mjs';\nimport { matchMutation, noop } from './utils.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\n// CLASS\nclass MutationCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.mutations = [];\n    this.mutationId = 0;\n  }\n\n  build(client, options, state) {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : undefined\n    });\n    this.add(mutation);\n    return mutation;\n  }\n\n  add(mutation) {\n    this.mutations.push(mutation);\n    this.notify({\n      type: 'added',\n      mutation\n    });\n  }\n\n  remove(mutation) {\n    this.mutations = this.mutations.filter(x => x !== mutation);\n    this.notify({\n      type: 'removed',\n      mutation\n    });\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.mutations.forEach(mutation => {\n        this.remove(mutation);\n      });\n    });\n  }\n\n  getAll() {\n    return this.mutations;\n  }\n\n  find(filters) {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.mutations.find(mutation => matchMutation(filters, mutation));\n  }\n\n  findAll(filters) {\n    return this.mutations.filter(mutation => matchMutation(filters, mutation));\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({\n        listener\n      }) => {\n        listener(event);\n      });\n    });\n  }\n\n  resumePausedMutations() {\n    var _this$resuming;\n\n    this.resuming = ((_this$resuming = this.resuming) != null ? _this$resuming : Promise.resolve()).then(() => {\n      const pausedMutations = this.mutations.filter(x => x.state.isPaused);\n      return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));\n    }).then(() => {\n      this.resuming = undefined;\n    });\n    return this.resuming;\n  }\n\n}\n\nexport { MutationCache };\n//# sourceMappingURL=mutationCache.mjs.map\n","function infiniteQueryBehavior() {\n  return {\n    onFetch: context => {\n      context.fetchFn = () => {\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n\n        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        let newPageParams = oldPageParams;\n        let cancelled = false;\n\n        const addSignalProperty = object => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              var _context$signal;\n\n              if ((_context$signal = context.signal) != null && _context$signal.aborted) {\n                cancelled = true;\n              } else {\n                var _context$signal2;\n\n                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener('abort', () => {\n                  cancelled = true;\n                });\n              }\n\n              return context.signal;\n            }\n          });\n        }; // Get query function\n\n\n        const queryFn = context.options.queryFn || (() => Promise.reject(\"Missing queryFn for queryKey '\" + context.options.queryHash + \"'\"));\n\n        const buildNewPages = (pages, param, page, previous) => {\n          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];\n          return previous ? [page, ...pages] : [...pages, page];\n        }; // Create function to fetch a page\n\n\n        const fetchPage = (pages, manual, param, previous) => {\n          if (cancelled) {\n            return Promise.reject('Cancelled');\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.options.meta\n          };\n          addSignalProperty(queryFnContext);\n          const queryFnResult = queryFn(queryFnContext);\n          const promise = Promise.resolve(queryFnResult).then(page => buildNewPages(pages, param, page, previous));\n          return promise;\n        };\n\n        let promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param);\n        } // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param, true);\n        } // Refetch pages\n        else {\n          newPageParams = [];\n          const manual = typeof context.options.getNextPageParam === 'undefined';\n          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n\n          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then(pages => {\n              const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n\n              if (shouldFetchNextPage) {\n                const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n                return fetchPage(pages, manual, param);\n              }\n\n              return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n            });\n          }\n        }\n\n        const finalPromise = promise.then(pages => ({\n          pages,\n          pageParams: newPageParams\n        }));\n        return finalPromise;\n      };\n    }\n  };\n}\nfunction getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nfunction getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n\n  return;\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n\n  return;\n}\n\nexport { getNextPageParam, getPreviousPageParam, hasNextPage, hasPreviousPage, infiniteQueryBehavior };\n//# sourceMappingURL=infiniteQueryBehavior.mjs.map\n","import { parseFilterArgs, parseQueryArgs, functionalUpdate, noop, hashQueryKey, partialMatchKey, hashQueryKeyByOptions } from './utils.mjs';\nimport { QueryCache } from './queryCache.mjs';\nimport { MutationCache } from './mutationCache.mjs';\nimport { focusManager } from './focusManager.mjs';\nimport { onlineManager } from './onlineManager.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior.mjs';\nimport { defaultLogger } from './logger.mjs';\n\n// CLASS\nclass QueryClient {\n  constructor(config = {}) {\n    this.queryCache = config.queryCache || new QueryCache();\n    this.mutationCache = config.mutationCache || new MutationCache();\n    this.logger = config.logger || defaultLogger;\n    this.defaultOptions = config.defaultOptions || {};\n    this.queryDefaults = [];\n    this.mutationDefaults = [];\n    this.mountCount = 0;\n\n    if (process.env.NODE_ENV !== 'production' && config.logger) {\n      this.logger.error(\"Passing a custom logger has been deprecated and will be removed in the next major version.\");\n    }\n  }\n\n  mount() {\n    this.mountCount++;\n    if (this.mountCount !== 1) return;\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations();\n        this.queryCache.onFocus();\n      }\n    });\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations();\n        this.queryCache.onOnline();\n      }\n    });\n  }\n\n  unmount() {\n    var _this$unsubscribeFocu, _this$unsubscribeOnli;\n\n    this.mountCount--;\n    if (this.mountCount !== 0) return;\n    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);\n    this.unsubscribeFocus = undefined;\n    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);\n    this.unsubscribeOnline = undefined;\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  isFetching(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    filters.fetchStatus = 'fetching';\n    return this.queryCache.findAll(filters).length;\n  }\n\n  isMutating(filters) {\n    return this.mutationCache.findAll({ ...filters,\n      fetching: true\n    }).length;\n  }\n\n  /**\n   * @deprecated This method will accept only queryKey in the next major version.\n   */\n  getQueryData(queryKey, filters) {\n    var _this$queryCache$find;\n\n    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  ensureQueryData(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const cachedData = this.getQueryData(parsedOptions.queryKey);\n    return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(parsedOptions);\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  getQueriesData(queryKeyOrFilters) {\n    return this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey,\n      state\n    }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n\n  setQueryData(queryKey, updater, options) {\n    const query = this.queryCache.find(queryKey);\n    const prevData = query == null ? void 0 : query.state.data;\n    const data = functionalUpdate(updater, prevData);\n\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions);\n    return this.queryCache.build(this, defaultedOptions).setData(data, { ...options,\n      manual: true\n    });\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  setQueriesData(queryKeyOrFilters, updater, options) {\n    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey\n    }) => [queryKey, this.setQueryData(queryKey, updater, options)]));\n  }\n\n  getQueryState(queryKey,\n  /**\n   * @deprecated This filters will be removed in the next major version.\n   */\n  filters) {\n    var _this$queryCache$find2;\n\n    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  removeQueries(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    const queryCache = this.queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  resetQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const queryCache = this.queryCache;\n    const refetchFilters = {\n      type: 'active',\n      ...filters\n    };\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  cancelQueries(arg1, arg2, arg3) {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true;\n    }\n\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  invalidateQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    return notifyManager.batch(() => {\n      var _ref, _filters$refetchType;\n\n      this.queryCache.findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve();\n      }\n\n      const refetchFilters = { ...filters,\n        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  refetchQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {\n      var _options$cancelRefetc;\n\n      return query.fetch(undefined, { ...options,\n        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,\n        meta: {\n          refetchPage: filters.refetchPage\n        }\n      });\n    }));\n    let promise = Promise.all(promises).then(noop);\n\n    if (!(options != null && options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  fetchQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652\n\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false;\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  prefetchQuery(arg1, arg2, arg3) {\n    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  fetchInfiniteQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    parsedOptions.behavior = infiniteQueryBehavior();\n    return this.fetchQuery(parsedOptions);\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  prefetchInfiniteQuery(arg1, arg2, arg3) {\n    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  resumePausedMutations() {\n    return this.mutationCache.resumePausedMutations();\n  }\n\n  getQueryCache() {\n    return this.queryCache;\n  }\n\n  getMutationCache() {\n    return this.mutationCache;\n  }\n\n  getLogger() {\n    return this.logger;\n  }\n\n  getDefaultOptions() {\n    return this.defaultOptions;\n  }\n\n  setDefaultOptions(options) {\n    this.defaultOptions = options;\n  }\n\n  setQueryDefaults(queryKey, options) {\n    const result = this.queryDefaults.find(x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.queryDefaults.push({\n        queryKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getQueryDefaults(queryKey) {\n    if (!queryKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter(x => partialMatchKey(queryKey, x.queryKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\"[QueryClient] Several query defaults match with key '\" + JSON.stringify(queryKey) + \"'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.\");\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  setMutationDefaults(mutationKey, options) {\n    const result = this.mutationDefaults.find(x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.mutationDefaults.push({\n        mutationKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getMutationDefaults(mutationKey) {\n    if (!mutationKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.mutationDefaults.find(x => partialMatchKey(mutationKey, x.mutationKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter(x => partialMatchKey(mutationKey, x.mutationKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\"[QueryClient] Several mutation defaults match with key '\" + JSON.stringify(mutationKey) + \"'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.\");\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  defaultQueryOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    const defaultedOptions = { ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    } // dependent default values\n\n\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';\n    }\n\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;\n    }\n\n    return defaultedOptions;\n  }\n\n  defaultMutationOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    return { ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n\n  clear() {\n    this.queryCache.clear();\n    this.mutationCache.clear();\n  }\n\n}\n\nexport { QueryClient };\n//# sourceMappingURL=queryClient.mjs.map\n","import { shallowEqualObjects, noop, isServer, isValidTimeout, timeUntilStale, replaceData } from './utils.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { focusManager } from './focusManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\nimport { canFetch, isCancelledError } from './retryer.mjs';\n\nclass QueryObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.options = options;\n    this.trackedProps = new Set();\n    this.selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n\n  bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  }\n\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.currentQuery.addObserver(this);\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);\n  }\n\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n  }\n\n  destroy() {\n    this.listeners = new Set();\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n    this.currentQuery.removeObserver(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryOptions(options);\n\n    if (process.env.NODE_ENV !== 'production' && typeof (options == null ? void 0 : options.isDataEqual) !== 'undefined') {\n      this.client.getLogger().error(\"The isDataEqual option has been deprecated and will be removed in the next major version. You can achieve the same functionality by passing a function as the structuralSharing option\");\n    }\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.currentQuery,\n        observer: this\n      });\n    }\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery();\n    const mounted = this.hasListeners(); // Fetch if there are subscribers\n\n    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {\n      this.executeFetch();\n    } // Update result\n\n\n    this.updateResult(notifyOptions); // Update stale interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.updateStaleTimeout();\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {\n      this.updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n\n  getOptimisticResult(options) {\n    const query = this.client.getQueryCache().build(this.client, options);\n    const result = this.createResult(query, options);\n\n    if (shouldAssignObserverCurrentProperties(this, result, options)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult everytime\n      // an observer reads an optimistic value.\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.currentResult = result;\n      this.currentResultOptions = this.options;\n      this.currentResultState = this.currentQuery.state;\n    }\n\n    return result;\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  trackResult(result) {\n    const trackedResult = {};\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n\n  getCurrentQuery() {\n    return this.currentQuery;\n  }\n\n  remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  }\n\n  refetch({\n    refetchPage,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        refetchPage\n      }\n    });\n  }\n\n  fetchOptimistic(options) {\n    const defaultedOptions = this.client.defaultQueryOptions(options);\n    const query = this.client.getQueryCache().build(this.client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n\n  fetch(fetchOptions) {\n    var _fetchOptions$cancelR;\n\n    return this.executeFetch({ ...fetchOptions,\n      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true\n    }).then(() => {\n      this.updateResult();\n      return this.currentResult;\n    });\n  }\n\n  executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    let promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions != null && fetchOptions.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  updateStaleTimeout() {\n    this.clearStaleTimeout();\n\n    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    const timeout = time + 1;\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n\n  computeRefetchInterval() {\n    var _this$options$refetch;\n\n    return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;\n  }\n\n  updateRefetchInterval(nextInterval) {\n    this.clearRefetchInterval();\n    this.currentRefetchInterval = nextInterval;\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.executeFetch();\n      }\n    }, this.currentRefetchInterval);\n  }\n\n  updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval(this.computeRefetchInterval());\n  }\n\n  clearStaleTimeout() {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId);\n      this.staleTimeoutId = undefined;\n    }\n  }\n\n  clearRefetchInterval() {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId);\n      this.refetchIntervalId = undefined;\n    }\n  }\n\n  createResult(query, options) {\n    const prevQuery = this.currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.currentResult;\n    const prevResultState = this.currentResultState;\n    const prevResultOptions = this.currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;\n    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;\n    const {\n      state\n    } = query;\n    let {\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      fetchStatus,\n      status\n    } = state;\n    let isPreviousData = false;\n    let isPlaceholderData = false;\n    let data; // Optimistically set result in fetching state if needed\n\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode) ? 'fetching' : 'paused';\n\n        if (!dataUpdatedAt) {\n          status = 'loading';\n        }\n      }\n\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle';\n      }\n    } // Keep previous data if needed\n\n\n    if (options.keepPreviousData && !state.dataUpdatedAt && prevQueryResult != null && prevQueryResult.isSuccess && status !== 'error') {\n      data = prevQueryResult.data;\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt;\n      status = prevQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {\n        data = this.selectResult;\n      } else {\n        try {\n          this.selectFn = options.select;\n          data = options.select(state.data);\n          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);\n          this.selectResult = data;\n          this.selectError = null;\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError);\n          }\n\n          this.selectError = selectError;\n        }\n      }\n    } // Use query data\n    else {\n      data = state.data;\n    } // Show placeholder data if needed\n\n\n    if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\n      let placeholderData; // Memoize placeholder data\n\n      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;\n\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData);\n            this.selectError = null;\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError);\n            }\n\n            this.selectError = selectError;\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);\n        isPlaceholderData = true;\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError;\n      data = this.selectResult;\n      errorUpdatedAt = Date.now();\n      status = 'error';\n    }\n\n    const isFetching = fetchStatus === 'fetching';\n    const isLoading = status === 'loading';\n    const isError = status === 'error';\n    const result = {\n      status,\n      fetchStatus,\n      isLoading,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading && isFetching,\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isLoading,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove\n    };\n    return result;\n  }\n\n  updateResult(notifyOptions) {\n    const prevResult = this.currentResult;\n    const nextResult = this.createResult(this.currentQuery, this.options);\n    this.currentResultState = this.currentQuery.state;\n    this.currentResultOptions = this.options; // Only notify and update result if something has changed\n\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n\n    this.currentResult = nextResult; // Determine which callbacks to trigger\n\n    const defaultNotifyOptions = {\n      cache: true\n    };\n\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n\n      const {\n        notifyOnChangeProps\n      } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === 'function' ? notifyOnChangeProps() : notifyOnChangeProps;\n\n      if (notifyOnChangePropsValue === 'all' || !notifyOnChangePropsValue && !this.trackedProps.size) {\n        return true;\n      }\n\n      const includedProps = new Set(notifyOnChangePropsValue != null ? notifyOnChangePropsValue : this.trackedProps);\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error');\n      }\n\n      return Object.keys(this.currentResult).some(key => {\n        const typedKey = key;\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n\n    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n\n    this.notify({ ...defaultNotifyOptions,\n      ...notifyOptions\n    });\n  }\n\n  updateQuery() {\n    const query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === this.currentQuery) {\n      return;\n    }\n\n    const prevQuery = this.currentQuery;\n    this.currentQuery = query;\n    this.currentQueryInitialState = query.state;\n    this.previousQueryResult = this.currentResult;\n\n    if (this.hasListeners()) {\n      prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n\n  onQueryUpdate(action) {\n    const notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual;\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true;\n    }\n\n    this.updateResult(notifyOptions);\n\n    if (this.hasListeners()) {\n      this.updateTimers();\n    }\n  }\n\n  notify(notifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;\n\n        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);\n        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;\n\n        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);\n        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, undefined, this.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(({\n          listener\n        }) => {\n          listener(this.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated'\n        });\n      }\n    });\n  }\n\n}\n\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field;\n    return value === 'always' || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n} // this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\n\n\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult, options) {\n  // it is important to keep this condition like this for three reasons:\n  // 1. It will get removed in the v5\n  // 2. it reads: don't update the properties if we want to keep the previous\n  // data.\n  // 3. The opposite condition (!options.keepPreviousData) would fallthrough\n  // and will result in a bad decision\n  if (options.keepPreviousData) {\n    return false;\n  } // this means we want to put some placeholder data when pending and queryKey\n  // changed.\n\n\n  if (options.placeholderData !== undefined) {\n    // re-assign properties only if current data is placeholder data\n    // which means that data did not arrive yet, so, if there is some cached data\n    // we need to \"prepare\" to receive it\n    return optimisticResult.isPlaceholderData;\n  } // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n\n\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  } // basically, just keep previous properties if nothing changed\n\n\n  return false;\n}\n\nexport { QueryObserver };\n//# sourceMappingURL=queryObserver.mjs.map\n","import { difference, replaceAt } from './utils.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { QueryObserver } from './queryObserver.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\nclass QueriesObserver extends Subscribable {\n  constructor(client, queries) {\n    super();\n    this.client = client;\n    this.queries = [];\n    this.result = [];\n    this.observers = [];\n    this.observersMap = {};\n\n    if (queries) {\n      this.setQueries(queries);\n    }\n  }\n\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.size) {\n      this.destroy();\n    }\n  }\n\n  destroy() {\n    this.listeners = new Set();\n    this.observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n\n  setQueries(queries, notifyOptions) {\n    this.queries = queries;\n    notifyManager.batch(() => {\n      const prevObservers = this.observers;\n      const newObserverMatches = this.findMatchingObservers(this.queries); // set options for the new observers to notify of changes\n\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newObserversMap = Object.fromEntries(newObservers.map(observer => [observer.options.queryHash, observer]));\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n\n      this.observers = newObservers;\n      this.observersMap = newObserversMap;\n      this.result = newResult;\n\n      if (!this.hasListeners()) {\n        return;\n      }\n\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n      this.notify();\n    });\n  }\n\n  getCurrentResult() {\n    return this.result;\n  }\n\n  getQueries() {\n    return this.observers.map(observer => observer.getCurrentQuery());\n  }\n\n  getObservers() {\n    return this.observers;\n  }\n\n  getOptimisticResult(queries) {\n    return this.findMatchingObservers(queries).map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n  }\n\n  findMatchingObservers(queries) {\n    const prevObservers = this.observers;\n    const prevObserversMap = new Map(prevObservers.map(observer => [observer.options.queryHash, observer]));\n    const defaultedQueryOptions = queries.map(options => this.client.defaultQueryOptions(options));\n    const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {\n      const match = prevObserversMap.get(defaultedOptions.queryHash);\n\n      if (match != null) {\n        return [{\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        }];\n      }\n\n      return [];\n    });\n    const matchedQueryHashes = new Set(matchingObservers.map(match => match.defaultedQueryOptions.queryHash));\n    const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.has(defaultedOptions.queryHash));\n    const matchingObserversSet = new Set(matchingObservers.map(match => match.observer));\n    const unmatchedObservers = prevObservers.filter(prevObserver => !matchingObserversSet.has(prevObserver));\n\n    const getObserver = options => {\n      const defaultedOptions = this.client.defaultQueryOptions(options);\n      const currentObserver = this.observersMap[defaultedOptions.queryHash];\n      return currentObserver != null ? currentObserver : new QueryObserver(this.client, defaultedOptions);\n    };\n\n    const newOrReusedObservers = unmatchedQueries.map((options, index) => {\n      if (options.keepPreviousData) {\n        // return previous data from one of the observers that no longer match\n        const previouslyUsedObserver = unmatchedObservers[index];\n\n        if (previouslyUsedObserver !== undefined) {\n          return {\n            defaultedQueryOptions: options,\n            observer: previouslyUsedObserver\n          };\n        }\n      }\n\n      return {\n        defaultedQueryOptions: options,\n        observer: getObserver(options)\n      };\n    });\n\n    const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);\n\n    return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);\n  }\n\n  onUpdate(observer, result) {\n    const index = this.observers.indexOf(observer);\n\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result);\n      this.notify();\n    }\n  }\n\n  notify() {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({\n        listener\n      }) => {\n        listener(this.result);\n      });\n    });\n  }\n\n}\n\nexport { QueriesObserver };\n//# sourceMappingURL=queriesObserver.mjs.map\n","import { QueryObserver } from './queryObserver.mjs';\nimport { infiniteQueryBehavior, hasNextPage, hasPreviousPage } from './infiniteQueryBehavior.mjs';\n\nclass InfiniteQueryObserver extends QueryObserver {\n  // Type override\n  // Type override\n  // Type override\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(client, options) {\n    super(client, options);\n  }\n\n  bindMethods() {\n    super.bindMethods();\n    this.fetchNextPage = this.fetchNextPage.bind(this);\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    super.setOptions({ ...options,\n      behavior: infiniteQueryBehavior()\n    }, notifyOptions);\n  }\n\n  getOptimisticResult(options) {\n    options.behavior = infiniteQueryBehavior();\n    return super.getOptimisticResult(options);\n  }\n\n  fetchNextPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'forward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  fetchPreviousPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'backward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  createResult(query, options) {\n    var _state$fetchMeta, _state$fetchMeta$fetc, _state$fetchMeta2, _state$fetchMeta2$fet, _state$data, _state$data2;\n\n    const {\n      state\n    } = query;\n    const result = super.createResult(query, options);\n    const {\n      isFetching,\n      isRefetching\n    } = result;\n    const isFetchingNextPage = isFetching && ((_state$fetchMeta = state.fetchMeta) == null ? void 0 : (_state$fetchMeta$fetc = _state$fetchMeta.fetchMore) == null ? void 0 : _state$fetchMeta$fetc.direction) === 'forward';\n    const isFetchingPreviousPage = isFetching && ((_state$fetchMeta2 = state.fetchMeta) == null ? void 0 : (_state$fetchMeta2$fet = _state$fetchMeta2.fetchMore) == null ? void 0 : _state$fetchMeta2$fet.direction) === 'backward';\n    return { ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, (_state$data = state.data) == null ? void 0 : _state$data.pages),\n      hasPreviousPage: hasPreviousPage(options, (_state$data2 = state.data) == null ? void 0 : _state$data2.pages),\n      isFetchingNextPage,\n      isFetchingPreviousPage,\n      isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage\n    };\n  }\n\n}\n\nexport { InfiniteQueryObserver };\n//# sourceMappingURL=infiniteQueryObserver.mjs.map\n","import { getDefaultState } from './mutation.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\nimport { shallowEqualObjects } from './utils.mjs';\n\n// CLASS\nclass MutationObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.setOptions(options);\n    this.bindMethods();\n    this.updateResult();\n  }\n\n  bindMethods() {\n    this.mutate = this.mutate.bind(this);\n    this.reset = this.reset.bind(this);\n  }\n\n  setOptions(options) {\n    var _this$currentMutation;\n\n    const prevOptions = this.options;\n    this.options = this.client.defaultMutationOptions(options);\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.currentMutation,\n        observer: this\n      });\n    }\n\n    (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.setOptions(this.options);\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$currentMutation2;\n\n      (_this$currentMutation2 = this.currentMutation) == null ? void 0 : _this$currentMutation2.removeObserver(this);\n    }\n  }\n\n  onMutationUpdate(action) {\n    this.updateResult(); // Determine which callbacks to trigger\n\n    const notifyOptions = {\n      listeners: true\n    };\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true;\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true;\n    }\n\n    this.notify(notifyOptions);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  reset() {\n    this.currentMutation = undefined;\n    this.updateResult();\n    this.notify({\n      listeners: true\n    });\n  }\n\n  mutate(variables, options) {\n    this.mutateOptions = options;\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this);\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, { ...this.options,\n      variables: typeof variables !== 'undefined' ? variables : this.options.variables\n    });\n    this.currentMutation.addObserver(this);\n    return this.currentMutation.execute();\n  }\n\n  updateResult() {\n    const state = this.currentMutation ? this.currentMutation.state : getDefaultState();\n    const isLoading = state.status === 'loading';\n    const result = { ...state,\n      isLoading,\n      isPending: isLoading,\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset\n    };\n    this.currentResult = result;\n  }\n\n  notify(options) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions && this.hasListeners()) {\n        if (options.onSuccess) {\n          var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;\n\n          (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);\n        } else if (options.onError) {\n          var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;\n\n          (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, undefined, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n        }\n      } // Then trigger the listeners\n\n\n      if (options.listeners) {\n        this.listeners.forEach(({\n          listener\n        }) => {\n          listener(this.currentResult);\n        });\n      }\n    });\n  }\n\n}\n\nexport { MutationObserver };\n//# sourceMappingURL=mutationObserver.mjs.map\n","/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function useSyncExternalStore$2(subscribe, getSnapshot) {\n      didWarnOld18Alpha ||\n        void 0 === React.startTransition ||\n        ((didWarnOld18Alpha = !0),\n        console.error(\n          \"You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.\"\n        ));\n      var value = getSnapshot();\n      if (!didWarnUncachedGetSnapshot) {\n        var cachedValue = getSnapshot();\n        objectIs(value, cachedValue) ||\n          (console.error(\n            \"The result of getSnapshot should be cached to avoid an infinite loop\"\n          ),\n          (didWarnUncachedGetSnapshot = !0));\n      }\n      cachedValue = useState({\n        inst: { value: value, getSnapshot: getSnapshot }\n      });\n      var inst = cachedValue[0].inst,\n        forceUpdate = cachedValue[1];\n      useLayoutEffect(\n        function () {\n          inst.value = value;\n          inst.getSnapshot = getSnapshot;\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n        },\n        [subscribe, value, getSnapshot]\n      );\n      useEffect(\n        function () {\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          return subscribe(function () {\n            checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          });\n        },\n        [subscribe]\n      );\n      useDebugValue(value);\n      return value;\n    }\n    function checkIfSnapshotChanged(inst) {\n      var latestGetSnapshot = inst.getSnapshot;\n      inst = inst.value;\n      try {\n        var nextValue = latestGetSnapshot();\n        return !objectIs(inst, nextValue);\n      } catch (error) {\n        return !0;\n      }\n    }\n    function useSyncExternalStore$1(subscribe, getSnapshot) {\n      return getSnapshot();\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = require(\"react\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useState = React.useState,\n      useEffect = React.useEffect,\n      useLayoutEffect = React.useLayoutEffect,\n      useDebugValue = React.useDebugValue,\n      didWarnOld18Alpha = !1,\n      didWarnUncachedGetSnapshot = !1,\n      shim =\n        \"undefined\" === typeof window ||\n        \"undefined\" === typeof window.document ||\n        \"undefined\" === typeof window.document.createElement\n          ? useSyncExternalStore$1\n          : useSyncExternalStore$2;\n    exports.useSyncExternalStore =\n      void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n","'use client';\nimport { useSyncExternalStore as useSyncExternalStore$1 } from 'use-sync-external-store/shim/index.js';\n\nconst useSyncExternalStore = useSyncExternalStore$1;\n\nexport { useSyncExternalStore };\n//# sourceMappingURL=useSyncExternalStore.mjs.map\n","'use client';\nimport * as React from 'react';\n\nconst defaultContext = /*#__PURE__*/React.createContext(undefined);\nconst QueryClientSharingContext = /*#__PURE__*/React.createContext(false); // If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\n\nfunction getQueryClientContext(context, contextSharing) {\n  if (context) {\n    return context;\n  }\n\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext;\n    }\n\n    return window.ReactQueryClientContext;\n  }\n\n  return defaultContext;\n}\n\nconst useQueryClient = ({\n  context\n} = {}) => {\n  const queryClient = React.useContext(getQueryClientContext(context, React.useContext(QueryClientSharingContext)));\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one');\n  }\n\n  return queryClient;\n};\nconst QueryClientProvider = ({\n  client,\n  children,\n  context,\n  contextSharing = false\n}) => {\n  React.useEffect(() => {\n    client.mount();\n    return () => {\n      client.unmount();\n    };\n  }, [client]);\n\n  if (process.env.NODE_ENV !== 'production' && contextSharing) {\n    client.getLogger().error(\"The contextSharing option has been deprecated and will be removed in the next major version\");\n  }\n\n  const Context = getQueryClientContext(context, contextSharing);\n  return /*#__PURE__*/React.createElement(QueryClientSharingContext.Provider, {\n    value: !context && contextSharing\n  }, /*#__PURE__*/React.createElement(Context.Provider, {\n    value: client\n  }, children));\n};\n\nexport { QueryClientProvider, defaultContext, useQueryClient };\n//# sourceMappingURL=QueryClientProvider.mjs.map\n","'use client';\nimport * as React from 'react';\n\nconst IsRestoringContext = /*#__PURE__*/React.createContext(false);\nconst useIsRestoring = () => React.useContext(IsRestoringContext);\nconst IsRestoringProvider = IsRestoringContext.Provider;\n\nexport { IsRestoringProvider, useIsRestoring };\n//# sourceMappingURL=isRestoring.mjs.map\n","'use client';\nimport * as React from 'react';\n\nfunction createValue() {\n  let isReset = false;\n  return {\n    clearReset: () => {\n      isReset = false;\n    },\n    reset: () => {\n      isReset = true;\n    },\n    isReset: () => {\n      return isReset;\n    }\n  };\n}\n\nconst QueryErrorResetBoundaryContext = /*#__PURE__*/React.createContext(createValue()); // HOOK\n\nconst useQueryErrorResetBoundary = () => React.useContext(QueryErrorResetBoundaryContext); // COMPONENT\n\nconst QueryErrorResetBoundary = ({\n  children\n}) => {\n  const [value] = React.useState(() => createValue());\n  return /*#__PURE__*/React.createElement(QueryErrorResetBoundaryContext.Provider, {\n    value: value\n  }, typeof children === 'function' ? children(value) : children);\n};\n\nexport { QueryErrorResetBoundary, useQueryErrorResetBoundary };\n//# sourceMappingURL=QueryErrorResetBoundary.mjs.map\n","function shouldThrowError(_useErrorBoundary, params) {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params);\n  }\n\n  return !!_useErrorBoundary;\n}\n\nexport { shouldThrowError };\n//# sourceMappingURL=utils.mjs.map\n","'use client';\nimport * as React from 'react';\nimport { shouldThrowError } from './utils.mjs';\n\nconst ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {\n  if (options.suspense || options.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false;\n    }\n  }\n};\nconst useClearResetErrorBoundary = errorResetBoundary => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset();\n  }, [errorResetBoundary]);\n};\nconst getHasError = ({\n  result,\n  errorResetBoundary,\n  useErrorBoundary,\n  query\n}) => {\n  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError(useErrorBoundary, [result.error, query]);\n};\n\nexport { ensurePreventErrorBoundaryRetry, getHasError, useClearResetErrorBoundary };\n//# sourceMappingURL=errorBoundaryUtils.mjs.map\n","const ensureStaleTime = defaultedOptions => {\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000;\n    }\n  }\n};\nconst willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;\nconst shouldSuspend = (defaultedOptions, result, isRestoring) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && willFetch(result, isRestoring);\nconst fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).then(({\n  data\n}) => {\n  defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);\n  defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);\n}).catch(error => {\n  errorResetBoundary.clearReset();\n  defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);\n  defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(undefined, error);\n});\n\nexport { ensureStaleTime, fetchOptimistic, shouldSuspend, willFetch };\n//# sourceMappingURL=suspense.mjs.map\n","'use client';\nimport * as React from 'react';\nimport { QueriesObserver, notifyManager } from '@tanstack/query-core';\nimport { useSyncExternalStore } from './useSyncExternalStore.mjs';\nimport { useQueryClient } from './QueryClientProvider.mjs';\nimport { useIsRestoring } from './isRestoring.mjs';\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary.mjs';\nimport { ensurePreventErrorBoundaryRetry, useClearResetErrorBoundary, getHasError } from './errorBoundaryUtils.mjs';\nimport { ensureStaleTime, shouldSuspend, fetchOptimistic, willFetch } from './suspense.mjs';\n\nfunction useQueries({\n  queries,\n  context\n}) {\n  const queryClient = useQueryClient({\n    context\n  });\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const defaultedQueries = React.useMemo(() => queries.map(options => {\n    const defaultedOptions = queryClient.defaultQueryOptions(options); // Make sure the results are already in fetching state before subscribing or updating options\n\n    defaultedOptions._optimisticResults = isRestoring ? 'isRestoring' : 'optimistic';\n    return defaultedOptions;\n  }), [queries, queryClient, isRestoring]);\n  defaultedQueries.forEach(query => {\n    ensureStaleTime(query);\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary);\n  });\n  useClearResetErrorBoundary(errorResetBoundary);\n  const [observer] = React.useState(() => new QueriesObserver(queryClient, defaultedQueries));\n  const optimisticResult = observer.getOptimisticResult(defaultedQueries);\n  useSyncExternalStore(React.useCallback(onStoreChange => isRestoring ? () => undefined : observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(defaultedQueries, {\n      listeners: false\n    });\n  }, [defaultedQueries, observer]);\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) => shouldSuspend(defaultedQueries[index], result, isRestoring));\n  const suspensePromises = shouldAtLeastOneSuspend ? optimisticResult.flatMap((result, index) => {\n    const options = defaultedQueries[index];\n    const queryObserver = observer.getObservers()[index];\n\n    if (options && queryObserver) {\n      if (shouldSuspend(options, result, isRestoring)) {\n        return fetchOptimistic(options, queryObserver, errorResetBoundary);\n      } else if (willFetch(result, isRestoring)) {\n        void fetchOptimistic(options, queryObserver, errorResetBoundary);\n      }\n    }\n\n    return [];\n  }) : [];\n\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises);\n  }\n\n  const observerQueries = observer.getQueries();\n  const firstSingleResultWhichShouldThrow = optimisticResult.find((result, index) => {\n    var _defaultedQueries$ind, _defaultedQueries$ind2;\n\n    return getHasError({\n      result,\n      errorResetBoundary,\n      useErrorBoundary: (_defaultedQueries$ind = (_defaultedQueries$ind2 = defaultedQueries[index]) == null ? void 0 : _defaultedQueries$ind2.useErrorBoundary) != null ? _defaultedQueries$ind : false,\n      query: observerQueries[index]\n    });\n  });\n\n  if (firstSingleResultWhichShouldThrow != null && firstSingleResultWhichShouldThrow.error) {\n    throw firstSingleResultWhichShouldThrow.error;\n  }\n\n  return optimisticResult;\n}\n\nexport { useQueries };\n//# sourceMappingURL=useQueries.mjs.map\n","'use client';\nimport * as React from 'react';\nimport { notifyManager } from '@tanstack/query-core';\nimport { useSyncExternalStore } from './useSyncExternalStore.mjs';\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary.mjs';\nimport { useQueryClient } from './QueryClientProvider.mjs';\nimport { useIsRestoring } from './isRestoring.mjs';\nimport { ensurePreventErrorBoundaryRetry, useClearResetErrorBoundary, getHasError } from './errorBoundaryUtils.mjs';\nimport { ensureStaleTime, shouldSuspend, fetchOptimistic } from './suspense.mjs';\n\nfunction useBaseQuery(options, Observer) {\n  const queryClient = useQueryClient({\n    context: options.context\n  });\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const defaultedOptions = queryClient.defaultQueryOptions(options); // Make sure results are optimistically set in fetching state before subscribing or updating options\n\n  defaultedOptions._optimisticResults = isRestoring ? 'isRestoring' : 'optimistic'; // Include callbacks in batch renders\n\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);\n  }\n\n  ensureStaleTime(defaultedOptions);\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);\n  useClearResetErrorBoundary(errorResetBoundary);\n  const [observer] = React.useState(() => new Observer(queryClient, defaultedOptions));\n  const result = observer.getOptimisticResult(defaultedOptions);\n  useSyncExternalStore(React.useCallback(onStoreChange => {\n    const unsubscribe = isRestoring ? () => undefined : observer.subscribe(notifyManager.batchCalls(onStoreChange)); // Update result to make sure we did not miss any query updates\n    // between creating the observer and subscribing to it.\n\n    observer.updateResult();\n    return unsubscribe;\n  }, [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, {\n      listeners: false\n    });\n  }, [defaultedOptions, observer]); // Handle suspense\n\n  if (shouldSuspend(defaultedOptions, result, isRestoring)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);\n  } // Handle error boundary\n\n\n  if (getHasError({\n    result,\n    errorResetBoundary,\n    useErrorBoundary: defaultedOptions.useErrorBoundary,\n    query: observer.getCurrentQuery()\n  })) {\n    throw result.error;\n  } // Handle result property usage tracking\n\n\n  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;\n}\n\nexport { useBaseQuery };\n//# sourceMappingURL=useBaseQuery.mjs.map\n","'use client';\nimport { parseQueryArgs, QueryObserver } from '@tanstack/query-core';\nimport { useBaseQuery } from './useBaseQuery.mjs';\n\nfunction useQuery(arg1, arg2, arg3) {\n  const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n  return useBaseQuery(parsedOptions, QueryObserver);\n}\n\nexport { useQuery };\n//# sourceMappingURL=useQuery.mjs.map\n","'use client';\nimport * as React from 'react';\nimport { parseMutationArgs, MutationObserver, notifyManager } from '@tanstack/query-core';\nimport { useSyncExternalStore } from './useSyncExternalStore.mjs';\nimport { useQueryClient } from './QueryClientProvider.mjs';\nimport { shouldThrowError } from './utils.mjs';\n\nfunction useMutation(arg1, arg2, arg3) {\n  const options = parseMutationArgs(arg1, arg2, arg3);\n  const queryClient = useQueryClient({\n    context: options.context\n  });\n  const [observer] = React.useState(() => new MutationObserver(queryClient, options));\n  React.useEffect(() => {\n    observer.setOptions(options);\n  }, [observer, options]);\n  const result = useSyncExternalStore(React.useCallback(onStoreChange => observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer]), () => observer.getCurrentResult(), () => observer.getCurrentResult());\n  const mutate = React.useCallback((variables, mutateOptions) => {\n    observer.mutate(variables, mutateOptions).catch(noop);\n  }, [observer]);\n\n  if (result.error && shouldThrowError(observer.options.useErrorBoundary, [result.error])) {\n    throw result.error;\n  }\n\n  return { ...result,\n    mutate,\n    mutateAsync: result.mutate\n  };\n} // eslint-disable-next-line @typescript-eslint/no-empty-function\n\nfunction noop() {}\n\nexport { useMutation };\n//# sourceMappingURL=useMutation.mjs.map\n","'use client';\nimport { parseQueryArgs, InfiniteQueryObserver } from '@tanstack/query-core';\nimport { useBaseQuery } from './useBaseQuery.mjs';\n\nfunction useInfiniteQuery(arg1, arg2, arg3) {\n  const options = parseQueryArgs(arg1, arg2, arg3);\n  return useBaseQuery(options, InfiniteQueryObserver);\n}\n\nexport { useInfiniteQuery };\n//# sourceMappingURL=useInfiniteQuery.mjs.map\n","function identity(x) {\n    return x;\n}\n\n/** @internal */ function pipeFromArray(fns) {\n    if (fns.length === 0) {\n        return identity;\n    }\n    if (fns.length === 1) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return fns[0];\n    }\n    return function piped(input) {\n        return fns.reduce((prev, fn)=>fn(prev), input);\n    };\n}\n\nfunction isObservable(x) {\n    return typeof x === 'object' && x !== null && 'subscribe' in x;\n}\nfunction observable(subscribe) {\n    const self = {\n        subscribe (observer) {\n            let teardownRef = null;\n            let isDone = false;\n            let unsubscribed = false;\n            let teardownImmediately = false;\n            function unsubscribe() {\n                if (teardownRef === null) {\n                    teardownImmediately = true;\n                    return;\n                }\n                if (unsubscribed) {\n                    return;\n                }\n                unsubscribed = true;\n                if (typeof teardownRef === 'function') {\n                    teardownRef();\n                } else if (teardownRef) {\n                    teardownRef.unsubscribe();\n                }\n            }\n            teardownRef = subscribe({\n                next (value) {\n                    if (isDone) {\n                        return;\n                    }\n                    observer.next?.(value);\n                },\n                error (err) {\n                    if (isDone) {\n                        return;\n                    }\n                    isDone = true;\n                    observer.error?.(err);\n                    unsubscribe();\n                },\n                complete () {\n                    if (isDone) {\n                        return;\n                    }\n                    isDone = true;\n                    observer.complete?.();\n                    unsubscribe();\n                }\n            });\n            if (teardownImmediately) {\n                unsubscribe();\n            }\n            return {\n                unsubscribe\n            };\n        },\n        pipe (...operations) {\n            return pipeFromArray(operations)(self);\n        }\n    };\n    return self;\n}\n\nexport { isObservable as i, observable as o };\n","export { i as isObservable, o as observable } from '../observable-ade1bad8.mjs';\n\nfunction share(_opts) {\n    return (originalObserver)=>{\n        let refCount = 0;\n        let subscription = null;\n        const observers = [];\n        function startIfNeeded() {\n            if (subscription) {\n                return;\n            }\n            subscription = originalObserver.subscribe({\n                next (value) {\n                    for (const observer of observers){\n                        observer.next?.(value);\n                    }\n                },\n                error (error) {\n                    for (const observer of observers){\n                        observer.error?.(error);\n                    }\n                },\n                complete () {\n                    for (const observer of observers){\n                        observer.complete?.();\n                    }\n                }\n            });\n        }\n        function resetIfNeeded() {\n            // \"resetOnRefCountZero\"\n            if (refCount === 0 && subscription) {\n                const _sub = subscription;\n                subscription = null;\n                _sub.unsubscribe();\n            }\n        }\n        return {\n            subscribe (observer) {\n                refCount++;\n                observers.push(observer);\n                startIfNeeded();\n                return {\n                    unsubscribe () {\n                        refCount--;\n                        resetIfNeeded();\n                        const index = observers.findIndex((v)=>v === observer);\n                        if (index > -1) {\n                            observers.splice(index, 1);\n                        }\n                    }\n                };\n            }\n        };\n    };\n}\n\nfunction map(project) {\n    return (originalObserver)=>{\n        return {\n            subscribe (observer) {\n                let index = 0;\n                const subscription = originalObserver.subscribe({\n                    next (value) {\n                        observer.next?.(project(value, index++));\n                    },\n                    error (error) {\n                        observer.error?.(error);\n                    },\n                    complete () {\n                        observer.complete?.();\n                    }\n                });\n                return subscription;\n            }\n        };\n    };\n}\n\nfunction tap(observer) {\n    return (originalObserver)=>{\n        return {\n            subscribe (observer2) {\n                return originalObserver.subscribe({\n                    next (v) {\n                        observer.next?.(v);\n                        observer2.next?.(v);\n                    },\n                    error (v) {\n                        observer.error?.(v);\n                        observer2.error?.(v);\n                    },\n                    complete () {\n                        observer.complete?.();\n                        observer2.complete?.();\n                    }\n                });\n            }\n        };\n    };\n}\n\nclass ObservableAbortError extends Error {\n    constructor(message){\n        super(message);\n        this.name = 'ObservableAbortError';\n        Object.setPrototypeOf(this, ObservableAbortError.prototype);\n    }\n}\n/** @internal */ function observableToPromise(observable) {\n    let abort;\n    const promise = new Promise((resolve, reject)=>{\n        let isDone = false;\n        function onDone() {\n            if (isDone) {\n                return;\n            }\n            isDone = true;\n            reject(new ObservableAbortError('This operation was aborted.'));\n            obs$.unsubscribe();\n        }\n        const obs$ = observable.subscribe({\n            next (data) {\n                isDone = true;\n                resolve(data);\n                onDone();\n            },\n            error (data) {\n                isDone = true;\n                reject(data);\n                onDone();\n            },\n            complete () {\n                isDone = true;\n                onDone();\n            }\n        });\n        abort = onDone;\n    });\n    return {\n        promise,\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        abort: abort\n    };\n}\n\nexport { map, observableToPromise, share, tap };\n","import { observable } from '@trpc/server/observable';\n\n/** @internal */ function createChain(opts) {\n    return observable((observer)=>{\n        function execute(index = 0, op = opts.op) {\n            const next = opts.links[index];\n            if (!next) {\n                throw new Error('No more links to execute - did you forget to add an ending link?');\n            }\n            const subscription = next({\n                op,\n                next (nextOp) {\n                    const nextObserver = execute(index + 1, nextOp);\n                    return nextObserver;\n                }\n            });\n            return subscription;\n        }\n        const obs$ = execute();\n        return obs$.subscribe(observer);\n    });\n}\n\nfunction asArray(value) {\n    return Array.isArray(value) ? value : [\n        value\n    ];\n}\nfunction splitLink(opts) {\n    return (runtime)=>{\n        const yes = asArray(opts.true).map((link)=>link(runtime));\n        const no = asArray(opts.false).map((link)=>link(runtime));\n        return (props)=>{\n            return observable((observer)=>{\n                const links = opts.condition(props.op) ? yes : no;\n                return createChain({\n                    op: props.op,\n                    links\n                }).subscribe(observer);\n            });\n        };\n    };\n}\n\nexport { createChain as c, splitLink as s };\n","/**\n * @internal\n */ function invert(obj) {\n    const newObj = Object.create(null);\n    for(const key in obj){\n        const v = obj[key];\n        newObj[v] = key;\n    }\n    return newObj;\n}\n\n// reference: https://www.jsonrpc.org/specification\n/**\n * JSON-RPC 2.0 Error codes\n *\n * `-32000` to `-32099` are reserved for implementation-defined server-errors.\n * For tRPC we're copying the last digits of HTTP 4XX errors.\n */ const TRPC_ERROR_CODES_BY_KEY = {\n    /**\n   * Invalid JSON was received by the server.\n   * An error occurred on the server while parsing the JSON text.\n   */ PARSE_ERROR: -32700,\n    /**\n   * The JSON sent is not a valid Request object.\n   */ BAD_REQUEST: -32600,\n    // Internal JSON-RPC error\n    INTERNAL_SERVER_ERROR: -32603,\n    NOT_IMPLEMENTED: -32603,\n    // Implementation specific errors\n    UNAUTHORIZED: -32001,\n    FORBIDDEN: -32003,\n    NOT_FOUND: -32004,\n    METHOD_NOT_SUPPORTED: -32005,\n    TIMEOUT: -32008,\n    CONFLICT: -32009,\n    PRECONDITION_FAILED: -32012,\n    PAYLOAD_TOO_LARGE: -32013,\n    UNPROCESSABLE_CONTENT: -32022,\n    TOO_MANY_REQUESTS: -32029,\n    CLIENT_CLOSED_REQUEST: -32099\n};\nconst TRPC_ERROR_CODES_BY_NUMBER = invert(TRPC_ERROR_CODES_BY_KEY);\n\nexport { TRPC_ERROR_CODES_BY_KEY as T, TRPC_ERROR_CODES_BY_NUMBER as a, invert as i };\n","import { i as invert, T as TRPC_ERROR_CODES_BY_KEY } from './codes-c924c3db.mjs';\n\nconst TRPC_ERROR_CODES_BY_NUMBER = invert(TRPC_ERROR_CODES_BY_KEY);\nconst JSONRPC2_TO_HTTP_CODE = {\n    PARSE_ERROR: 400,\n    BAD_REQUEST: 400,\n    UNAUTHORIZED: 401,\n    NOT_FOUND: 404,\n    FORBIDDEN: 403,\n    METHOD_NOT_SUPPORTED: 405,\n    TIMEOUT: 408,\n    CONFLICT: 409,\n    PRECONDITION_FAILED: 412,\n    PAYLOAD_TOO_LARGE: 413,\n    UNPROCESSABLE_CONTENT: 422,\n    TOO_MANY_REQUESTS: 429,\n    CLIENT_CLOSED_REQUEST: 499,\n    INTERNAL_SERVER_ERROR: 500,\n    NOT_IMPLEMENTED: 501\n};\nfunction getStatusCodeFromKey(code) {\n    return JSONRPC2_TO_HTTP_CODE[code] ?? 500;\n}\nfunction getHTTPStatusCode(json) {\n    const arr = Array.isArray(json) ? json : [\n        json\n    ];\n    const httpStatuses = new Set(arr.map((res)=>{\n        if ('error' in res) {\n            const data = res.error.data;\n            if (typeof data.httpStatus === 'number') {\n                return data.httpStatus;\n            }\n            const code = TRPC_ERROR_CODES_BY_NUMBER[res.error.code];\n            return getStatusCodeFromKey(code);\n        }\n        return 200;\n    }));\n    if (httpStatuses.size !== 1) {\n        return 207;\n    }\n    const httpStatus = httpStatuses.values().next().value;\n    return httpStatus;\n}\nfunction getHTTPStatusCodeFromError(error) {\n    return getStatusCodeFromKey(error.code);\n}\n\nconst noop = ()=>{\n// noop\n};\nfunction createInnerProxy(callback, path) {\n    const proxy = new Proxy(noop, {\n        get (_obj, key) {\n            if (typeof key !== 'string' || key === 'then') {\n                // special case for if the proxy is accidentally treated\n                // like a PromiseLike (like in `Promise.resolve(proxy)`)\n                return undefined;\n            }\n            return createInnerProxy(callback, [\n                ...path,\n                key\n            ]);\n        },\n        apply (_1, _2, args) {\n            const isApply = path[path.length - 1] === 'apply';\n            return callback({\n                args: isApply ? args.length >= 2 ? args[1] : [] : args,\n                path: isApply ? path.slice(0, -1) : path\n            });\n        }\n    });\n    return proxy;\n}\n/**\n * Creates a proxy that calls the callback with the path and arguments\n *\n * @internal\n */ const createRecursiveProxy = (callback)=>createInnerProxy(callback, []);\n/**\n * Used in place of `new Proxy` where each handler will map 1 level deep to another value.\n *\n * @internal\n */ const createFlatProxy = (callback)=>{\n    return new Proxy(noop, {\n        get (_obj, name) {\n            if (typeof name !== 'string' || name === 'then') {\n                // special case for if the proxy is accidentally treated\n                // like a PromiseLike (like in `Promise.resolve(proxy)`)\n                return undefined;\n            }\n            return callback(name);\n        }\n    });\n};\n\nexport { TRPC_ERROR_CODES_BY_NUMBER as T, createRecursiveProxy as a, getHTTPStatusCode as b, createFlatProxy as c, getHTTPStatusCodeFromError as g };\n","/**\n * @internal\n */ function isObject(value) {\n    // check that value is object\n    return !!value && !Array.isArray(value) && typeof value === 'object';\n}\n\nclass UnknownCauseError extends Error {\n}\nfunction getCauseFromUnknown(cause) {\n    if (cause instanceof Error) {\n        return cause;\n    }\n    const type = typeof cause;\n    if (type === 'undefined' || type === 'function' || cause === null) {\n        return undefined;\n    }\n    // Primitive types just get wrapped in an error\n    if (type !== 'object') {\n        return new Error(String(cause));\n    }\n    // If it's an object, we'll create a synthetic error\n    if (isObject(cause)) {\n        const err = new UnknownCauseError();\n        for(const key in cause){\n            err[key] = cause[key];\n        }\n        return err;\n    }\n    return undefined;\n}\n\nexport { getCauseFromUnknown as g };\n","function isObject(value) {\n    // check that value is object\n    return !!value && !Array.isArray(value) && typeof value === 'object';\n}\n\n// FIXME:\n// - the generics here are probably unnecessary\n// - the RPC-spec could probably be simplified to combine HTTP + WS\n/** @internal */ function transformResultInner(response, runtime) {\n    if ('error' in response) {\n        const error = runtime.transformer.deserialize(response.error);\n        return {\n            ok: false,\n            error: {\n                ...response,\n                error\n            }\n        };\n    }\n    const result = {\n        ...response.result,\n        ...(!response.result.type || response.result.type === 'data') && {\n            type: 'data',\n            data: runtime.transformer.deserialize(response.result.data)\n        }\n    };\n    return {\n        ok: true,\n        result\n    };\n}\nclass TransformResultError extends Error {\n    constructor(){\n        super('Unable to transform response from server');\n    }\n}\n/**\n * Transforms and validates that the result is a valid TRPCResponse\n * @internal\n */ function transformResult(response, runtime) {\n    let result;\n    try {\n        // Use the data transformers on the JSON-response\n        result = transformResultInner(response, runtime);\n    } catch (err) {\n        throw new TransformResultError();\n    }\n    // check that output of the transformers is a valid TRPCResponse\n    if (!result.ok && (!isObject(result.error.error) || typeof result.error.error.code !== 'number')) {\n        throw new TransformResultError();\n    }\n    if (result.ok && !isObject(result.result)) {\n        throw new TransformResultError();\n    }\n    return result;\n}\n\nexport { isObject as i, transformResult as t };\n","import { getCauseFromUnknown } from '@trpc/server/shared';\nimport { i as isObject } from './transformResult-ace864b8.mjs';\n\nfunction isTRPCClientError(cause) {\n    return cause instanceof TRPCClientError || /**\n     * @deprecated\n     * Delete in next major\n     */ cause instanceof Error && cause.name === 'TRPCClientError';\n}\nfunction isTRPCErrorResponse(obj) {\n    return isObject(obj) && isObject(obj.error) && typeof obj.error.code === 'number' && typeof obj.error.message === 'string';\n}\nclass TRPCClientError extends Error {\n    static from(_cause, opts = {}) {\n        const cause = _cause;\n        if (isTRPCClientError(cause)) {\n            if (opts.meta) {\n                // Decorate with meta error data\n                cause.meta = {\n                    ...cause.meta,\n                    ...opts.meta\n                };\n            }\n            return cause;\n        }\n        if (isTRPCErrorResponse(cause)) {\n            return new TRPCClientError(cause.error.message, {\n                ...opts,\n                result: cause\n            });\n        }\n        if (!(cause instanceof Error)) {\n            return new TRPCClientError('Unknown error', {\n                ...opts,\n                cause: cause\n            });\n        }\n        return new TRPCClientError(cause.message, {\n            ...opts,\n            cause: getCauseFromUnknown(cause)\n        });\n    }\n    constructor(message, opts){\n        const cause = opts?.cause;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore https://github.com/tc39/proposal-error-cause\n        super(message, {\n            cause\n        });\n        this.meta = opts?.meta;\n        this.cause = cause;\n        this.shape = opts?.result?.error;\n        this.data = opts?.result?.error.data;\n        this.name = 'TRPCClientError';\n        Object.setPrototypeOf(this, TRPCClientError.prototype);\n    }\n}\n\nexport { TRPCClientError as T };\n","import { T as TRPCClientError } from './TRPCClientError-38f9a32a.mjs';\n\nconst isFunction = (fn)=>typeof fn === 'function';\nfunction getFetch(customFetchImpl) {\n    if (customFetchImpl) {\n        return customFetchImpl;\n    }\n    if (typeof window !== 'undefined' && isFunction(window.fetch)) {\n        return window.fetch;\n    }\n    if (typeof globalThis !== 'undefined' && isFunction(globalThis.fetch)) {\n        return globalThis.fetch;\n    }\n    throw new Error('No fetch implementation found');\n}\n\nfunction getAbortController(customAbortControllerImpl) {\n    if (customAbortControllerImpl) {\n        return customAbortControllerImpl;\n    }\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (typeof window !== 'undefined' && window.AbortController) {\n        return window.AbortController;\n    }\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (typeof globalThis !== 'undefined' && globalThis.AbortController) {\n        return globalThis.AbortController;\n    }\n    return null;\n}\n\nfunction resolveHTTPLinkOptions(opts) {\n    return {\n        url: opts.url.toString().replace(/\\/$/, ''),\n        fetch: opts.fetch,\n        AbortController: getAbortController(opts.AbortController)\n    };\n}\n// https://github.com/trpc/trpc/pull/669\nfunction arrayToDict(array) {\n    const dict = {};\n    for(let index = 0; index < array.length; index++){\n        const element = array[index];\n        dict[index] = element;\n    }\n    return dict;\n}\nconst METHOD = {\n    query: 'GET',\n    mutation: 'POST'\n};\nfunction getInput(opts) {\n    return 'input' in opts ? opts.runtime.transformer.serialize(opts.input) : arrayToDict(opts.inputs.map((_input)=>opts.runtime.transformer.serialize(_input)));\n}\nconst getUrl = (opts)=>{\n    let url = opts.url + '/' + opts.path;\n    const queryParts = [];\n    if ('inputs' in opts) {\n        queryParts.push('batch=1');\n    }\n    if (opts.type === 'query') {\n        const input = getInput(opts);\n        if (input !== undefined) {\n            queryParts.push(`input=${encodeURIComponent(JSON.stringify(input))}`);\n        }\n    }\n    if (queryParts.length) {\n        url += '?' + queryParts.join('&');\n    }\n    return url;\n};\nconst getBody = (opts)=>{\n    if (opts.type === 'query') {\n        return undefined;\n    }\n    const input = getInput(opts);\n    return input !== undefined ? JSON.stringify(input) : undefined;\n};\nconst jsonHttpRequester = (opts)=>{\n    return httpRequest({\n        ...opts,\n        contentTypeHeader: 'application/json',\n        getUrl,\n        getBody\n    });\n};\nasync function fetchHTTPResponse(opts, ac) {\n    const url = opts.getUrl(opts);\n    const body = opts.getBody(opts);\n    const { type  } = opts;\n    const resolvedHeaders = await opts.headers();\n    /* istanbul ignore if -- @preserve */ if (type === 'subscription') {\n        throw new Error('Subscriptions should use wsLink');\n    }\n    const headers = {\n        ...opts.contentTypeHeader ? {\n            'content-type': opts.contentTypeHeader\n        } : {},\n        ...opts.batchModeHeader ? {\n            'trpc-batch-mode': opts.batchModeHeader\n        } : {},\n        ...resolvedHeaders\n    };\n    return getFetch(opts.fetch)(url, {\n        method: METHOD[type],\n        signal: ac?.signal,\n        body: body,\n        headers\n    });\n}\nfunction httpRequest(opts) {\n    const ac = opts.AbortController ? new opts.AbortController() : null;\n    const meta = {};\n    let done = false;\n    const promise = new Promise((resolve, reject)=>{\n        fetchHTTPResponse(opts, ac).then((_res)=>{\n            meta.response = _res;\n            done = true;\n            return _res.json();\n        }).then((json)=>{\n            meta.responseJSON = json;\n            resolve({\n                json: json,\n                meta\n            });\n        }).catch((err)=>{\n            done = true;\n            reject(TRPCClientError.from(err, {\n                meta\n            }));\n        });\n    });\n    const cancel = ()=>{\n        if (!done) {\n            ac?.abort();\n        }\n    };\n    return {\n        promise,\n        cancel\n    };\n}\n\nexport { getBody as a, getFetch as b, fetchHTTPResponse as f, getUrl as g, httpRequest as h, jsonHttpRequester as j, resolveHTTPLinkOptions as r };\n","import { observable } from '@trpc/server/observable';\nimport { t as transformResult } from './transformResult-ace864b8.mjs';\nimport { T as TRPCClientError } from './TRPCClientError-38f9a32a.mjs';\nimport { r as resolveHTTPLinkOptions, g as getUrl, j as jsonHttpRequester } from './httpUtils-b9d0cb48.mjs';\n\n/* eslint-disable @typescript-eslint/no-non-null-assertion */ /**\n * A function that should never be called unless we messed something up.\n */ const throwFatalError = ()=>{\n    throw new Error('Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new');\n};\n/**\n * Dataloader that's very inspired by https://github.com/graphql/dataloader\n * Less configuration, no caching, and allows you to cancel requests\n * When cancelling a single fetch the whole batch will be cancelled only when _all_ items are cancelled\n */ function dataLoader(batchLoader) {\n    let pendingItems = null;\n    let dispatchTimer = null;\n    const destroyTimerAndPendingItems = ()=>{\n        clearTimeout(dispatchTimer);\n        dispatchTimer = null;\n        pendingItems = null;\n    };\n    /**\n   * Iterate through the items and split them into groups based on the `batchLoader`'s validate function\n   */ function groupItems(items) {\n        const groupedItems = [\n            []\n        ];\n        let index = 0;\n        while(true){\n            const item = items[index];\n            if (!item) {\n                break;\n            }\n            const lastGroup = groupedItems[groupedItems.length - 1];\n            if (item.aborted) {\n                // Item was aborted before it was dispatched\n                item.reject?.(new Error('Aborted'));\n                index++;\n                continue;\n            }\n            const isValid = batchLoader.validate(lastGroup.concat(item).map((it)=>it.key));\n            if (isValid) {\n                lastGroup.push(item);\n                index++;\n                continue;\n            }\n            if (lastGroup.length === 0) {\n                item.reject?.(new Error('Input is too big for a single dispatch'));\n                index++;\n                continue;\n            }\n            // Create new group, next iteration will try to add the item to that\n            groupedItems.push([]);\n        }\n        return groupedItems;\n    }\n    function dispatch() {\n        const groupedItems = groupItems(pendingItems);\n        destroyTimerAndPendingItems();\n        // Create batches for each group of items\n        for (const items of groupedItems){\n            if (!items.length) {\n                continue;\n            }\n            const batch = {\n                items,\n                cancel: throwFatalError\n            };\n            for (const item of items){\n                item.batch = batch;\n            }\n            const unitResolver = (index, value)=>{\n                const item = batch.items[index];\n                item.resolve?.(value);\n                item.batch = null;\n                item.reject = null;\n                item.resolve = null;\n            };\n            const { promise , cancel  } = batchLoader.fetch(batch.items.map((_item)=>_item.key), unitResolver);\n            batch.cancel = cancel;\n            promise.then((result)=>{\n                for(let i = 0; i < result.length; i++){\n                    const value = result[i];\n                    unitResolver(i, value);\n                }\n                for (const item of batch.items){\n                    item.reject?.(new Error('Missing result'));\n                    item.batch = null;\n                }\n            }).catch((cause)=>{\n                for (const item of batch.items){\n                    item.reject?.(cause);\n                    item.batch = null;\n                }\n            });\n        }\n    }\n    function load(key) {\n        const item = {\n            aborted: false,\n            key,\n            batch: null,\n            resolve: throwFatalError,\n            reject: throwFatalError\n        };\n        const promise = new Promise((resolve, reject)=>{\n            item.reject = reject;\n            item.resolve = resolve;\n            if (!pendingItems) {\n                pendingItems = [];\n            }\n            pendingItems.push(item);\n        });\n        if (!dispatchTimer) {\n            dispatchTimer = setTimeout(dispatch);\n        }\n        const cancel = ()=>{\n            item.aborted = true;\n            if (item.batch?.items.every((item)=>item.aborted)) {\n                // All items in the batch have been cancelled\n                item.batch.cancel();\n                item.batch = null;\n            }\n        };\n        return {\n            promise,\n            cancel\n        };\n    }\n    return {\n        load\n    };\n}\n\n/**\n * @internal\n */ function createHTTPBatchLink(requester) {\n    return function httpBatchLink(opts) {\n        const resolvedOpts = resolveHTTPLinkOptions(opts);\n        const maxURLLength = opts.maxURLLength ?? Infinity;\n        // initialized config\n        return (runtime)=>{\n            const batchLoader = (type)=>{\n                const validate = (batchOps)=>{\n                    if (maxURLLength === Infinity) {\n                        // escape hatch for quick calcs\n                        return true;\n                    }\n                    const path = batchOps.map((op)=>op.path).join(',');\n                    const inputs = batchOps.map((op)=>op.input);\n                    const url = getUrl({\n                        ...resolvedOpts,\n                        runtime,\n                        type,\n                        path,\n                        inputs\n                    });\n                    return url.length <= maxURLLength;\n                };\n                const fetch = requester({\n                    ...resolvedOpts,\n                    runtime,\n                    type,\n                    opts\n                });\n                return {\n                    validate,\n                    fetch\n                };\n            };\n            const query = dataLoader(batchLoader('query'));\n            const mutation = dataLoader(batchLoader('mutation'));\n            const subscription = dataLoader(batchLoader('subscription'));\n            const loaders = {\n                query,\n                subscription,\n                mutation\n            };\n            return ({ op  })=>{\n                return observable((observer)=>{\n                    const loader = loaders[op.type];\n                    const { promise , cancel  } = loader.load(op);\n                    let _res = undefined;\n                    promise.then((res)=>{\n                        _res = res;\n                        const transformed = transformResult(res.json, runtime);\n                        if (!transformed.ok) {\n                            observer.error(TRPCClientError.from(transformed.error, {\n                                meta: res.meta\n                            }));\n                            return;\n                        }\n                        observer.next({\n                            context: res.meta,\n                            result: transformed.result\n                        });\n                        observer.complete();\n                    }).catch((err)=>{\n                        observer.error(TRPCClientError.from(err, {\n                            meta: _res?.meta\n                        }));\n                    });\n                    return ()=>{\n                        cancel();\n                    };\n                });\n            };\n        };\n    };\n}\n\nconst batchRequester = (requesterOpts)=>{\n    return (batchOps)=>{\n        const path = batchOps.map((op)=>op.path).join(',');\n        const inputs = batchOps.map((op)=>op.input);\n        const { promise , cancel  } = jsonHttpRequester({\n            ...requesterOpts,\n            path,\n            inputs,\n            headers () {\n                if (!requesterOpts.opts.headers) {\n                    return {};\n                }\n                if (typeof requesterOpts.opts.headers === 'function') {\n                    return requesterOpts.opts.headers({\n                        opList: batchOps\n                    });\n                }\n                return requesterOpts.opts.headers;\n            }\n        });\n        return {\n            promise: promise.then((res)=>{\n                const resJSON = Array.isArray(res.json) ? res.json : batchOps.map(()=>res.json);\n                const result = resJSON.map((item)=>({\n                        meta: res.meta,\n                        json: item\n                    }));\n                return result;\n            }),\n            cancel\n        };\n    };\n};\nconst httpBatchLink = createHTTPBatchLink(batchRequester);\n\nexport { createHTTPBatchLink as c, httpBatchLink as h };\n","import { observable } from '@trpc/server/observable';\nimport { t as transformResult } from '../transformResult-ace864b8.mjs';\nimport { T as TRPCClientError } from '../TRPCClientError-38f9a32a.mjs';\nimport '@trpc/server/shared';\n\n/* istanbul ignore next -- @preserve */ const retryDelay = (attemptIndex)=>attemptIndex === 0 ? 0 : Math.min(1000 * 2 ** attemptIndex, 30000);\n\nfunction createWSClient(opts) {\n    const { url , WebSocket: WebSocketImpl = WebSocket , retryDelayMs: retryDelayFn = retryDelay , onOpen , onClose ,  } = opts;\n    /* istanbul ignore next -- @preserve */ if (!WebSocketImpl) {\n        throw new Error(\"No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill\");\n    }\n    /**\n   * outgoing messages buffer whilst not open\n   */ let outgoing = [];\n    const pendingRequests = Object.create(null);\n    let connectAttempt = 0;\n    let dispatchTimer = null;\n    let connectTimer = null;\n    let activeConnection = createWS();\n    let state = 'connecting';\n    /**\n   * tries to send the list of messages\n   */ function dispatch() {\n        if (state !== 'open' || dispatchTimer) {\n            return;\n        }\n        dispatchTimer = setTimeout(()=>{\n            dispatchTimer = null;\n            if (outgoing.length === 1) {\n                // single send\n                activeConnection.send(JSON.stringify(outgoing.pop()));\n            } else {\n                // batch send\n                activeConnection.send(JSON.stringify(outgoing));\n            }\n            // clear\n            outgoing = [];\n        });\n    }\n    function tryReconnect() {\n        if (connectTimer !== null || state === 'closed') {\n            return;\n        }\n        const timeout = retryDelayFn(connectAttempt++);\n        reconnectInMs(timeout);\n    }\n    function reconnect() {\n        state = 'connecting';\n        const oldConnection = activeConnection;\n        activeConnection = createWS();\n        closeIfNoPending(oldConnection);\n    }\n    function reconnectInMs(ms) {\n        if (connectTimer) {\n            return;\n        }\n        state = 'connecting';\n        connectTimer = setTimeout(reconnect, ms);\n    }\n    function closeIfNoPending(conn) {\n        // disconnect as soon as there are are no pending result\n        const hasPendingRequests = Object.values(pendingRequests).some((p)=>p.ws === conn);\n        if (!hasPendingRequests) {\n            conn.close();\n        }\n    }\n    function closeActiveSubscriptions() {\n        Object.values(pendingRequests).forEach((req)=>{\n            if (req.type === 'subscription') {\n                req.callbacks.complete();\n            }\n        });\n    }\n    function resumeSubscriptionOnReconnect(req) {\n        if (outgoing.some((r)=>r.id === req.op.id)) {\n            return;\n        }\n        request(req.op, req.callbacks);\n    }\n    function createWS() {\n        const urlString = typeof url === 'function' ? url() : url;\n        const conn = new WebSocketImpl(urlString);\n        clearTimeout(connectTimer);\n        connectTimer = null;\n        conn.addEventListener('open', ()=>{\n            /* istanbul ignore next -- @preserve */ if (conn !== activeConnection) {\n                return;\n            }\n            connectAttempt = 0;\n            state = 'open';\n            onOpen?.();\n            dispatch();\n        });\n        conn.addEventListener('error', ()=>{\n            if (conn === activeConnection) {\n                tryReconnect();\n            }\n        });\n        const handleIncomingRequest = (req)=>{\n            if (req.method === 'reconnect' && conn === activeConnection) {\n                if (state === 'open') {\n                    onClose?.();\n                }\n                reconnect();\n                // notify subscribers\n                for (const pendingReq of Object.values(pendingRequests)){\n                    if (pendingReq.type === 'subscription') {\n                        resumeSubscriptionOnReconnect(pendingReq);\n                    }\n                }\n            }\n        };\n        const handleIncomingResponse = (data)=>{\n            const req = data.id !== null && pendingRequests[data.id];\n            if (!req) {\n                // do something?\n                return;\n            }\n            req.callbacks.next?.(data);\n            if (req.ws !== activeConnection && conn === activeConnection) {\n                const oldWs = req.ws;\n                // gracefully replace old connection with this\n                req.ws = activeConnection;\n                closeIfNoPending(oldWs);\n            }\n            if ('result' in data && data.result.type === 'stopped' && conn === activeConnection) {\n                req.callbacks.complete();\n            }\n        };\n        conn.addEventListener('message', ({ data  })=>{\n            const msg = JSON.parse(data);\n            if ('method' in msg) {\n                handleIncomingRequest(msg);\n            } else {\n                handleIncomingResponse(msg);\n            }\n            if (conn !== activeConnection || state === 'closed') {\n                // when receiving a message, we close old connection that has no pending requests\n                closeIfNoPending(conn);\n            }\n        });\n        conn.addEventListener('close', ({ code  })=>{\n            if (state === 'open') {\n                onClose?.({\n                    code\n                });\n            }\n            if (activeConnection === conn) {\n                // connection might have been replaced already\n                tryReconnect();\n            }\n            for (const [key, req] of Object.entries(pendingRequests)){\n                if (req.ws !== conn) {\n                    continue;\n                }\n                if (state === 'closed') {\n                    // If the connection was closed, we just call `complete()` on the request\n                    delete pendingRequests[key];\n                    req.callbacks.complete?.();\n                    continue;\n                }\n                // The connection was closed either unexpectedly or because of a reconnect\n                if (req.type === 'subscription') {\n                    // Subscriptions will resume after we've reconnected\n                    resumeSubscriptionOnReconnect(req);\n                } else {\n                    // Queries and mutations will error if interrupted\n                    delete pendingRequests[key];\n                    req.callbacks.error?.(TRPCClientError.from(new TRPCWebSocketClosedError('WebSocket closed prematurely')));\n                }\n            }\n        });\n        return conn;\n    }\n    function request(op, callbacks) {\n        const { type , input , path , id  } = op;\n        const envelope = {\n            id,\n            method: type,\n            params: {\n                input,\n                path\n            }\n        };\n        pendingRequests[id] = {\n            ws: activeConnection,\n            type,\n            callbacks,\n            op\n        };\n        // enqueue message\n        outgoing.push(envelope);\n        dispatch();\n        return ()=>{\n            const callbacks = pendingRequests[id]?.callbacks;\n            delete pendingRequests[id];\n            outgoing = outgoing.filter((msg)=>msg.id !== id);\n            callbacks?.complete?.();\n            if (activeConnection.readyState === WebSocketImpl.OPEN && op.type === 'subscription') {\n                outgoing.push({\n                    id,\n                    method: 'subscription.stop'\n                });\n                dispatch();\n            }\n        };\n    }\n    return {\n        close: ()=>{\n            state = 'closed';\n            onClose?.();\n            closeActiveSubscriptions();\n            closeIfNoPending(activeConnection);\n            clearTimeout(connectTimer);\n            connectTimer = null;\n        },\n        request,\n        getConnection () {\n            return activeConnection;\n        }\n    };\n}\nclass TRPCWebSocketClosedError extends Error {\n    constructor(message){\n        super(message);\n        this.name = 'TRPCWebSocketClosedError';\n        Object.setPrototypeOf(this, TRPCWebSocketClosedError.prototype);\n    }\n}\n/**\n * @see https://trpc.io/docs/client/links/wsLink\n */ function wsLink(opts) {\n    return (runtime)=>{\n        const { client  } = opts;\n        return ({ op  })=>{\n            return observable((observer)=>{\n                const { type , path , id , context  } = op;\n                const input = runtime.transformer.serialize(op.input);\n                const unsub = client.request({\n                    type,\n                    path,\n                    input,\n                    id,\n                    context\n                }, {\n                    error (err) {\n                        observer.error(err);\n                        unsub();\n                    },\n                    complete () {\n                        observer.complete();\n                    },\n                    next (message) {\n                        const transformed = transformResult(message, runtime);\n                        if (!transformed.ok) {\n                            observer.error(TRPCClientError.from(transformed.error));\n                            return;\n                        }\n                        observer.next({\n                            result: transformed.result\n                        });\n                        if (op.type !== 'subscription') {\n                            // if it isn't a subscription we don't care about next response\n                            unsub();\n                            observer.complete();\n                        }\n                    }\n                });\n                return ()=>{\n                    unsub();\n                };\n            });\n        };\n    };\n}\n\nexport { createWSClient, wsLink };\n","import { share, observableToPromise } from '@trpc/server/observable';\nimport { c as createChain } from './splitLink-4c75f7be.mjs';\nexport { s as splitLink } from './splitLink-4c75f7be.mjs';\nimport { T as TRPCClientError } from './TRPCClientError-38f9a32a.mjs';\nexport { T as TRPCClientError } from './TRPCClientError-38f9a32a.mjs';\nimport { createFlatProxy, createRecursiveProxy } from '@trpc/server/shared';\nimport { f as fetchHTTPResponse, g as getUrl, a as getBody$1, h as httpRequest } from './httpUtils-b9d0cb48.mjs';\nexport { b as getFetch } from './httpUtils-b9d0cb48.mjs';\nimport { c as createHTTPBatchLink } from './httpBatchLink-d0f9eac9.mjs';\nexport { h as httpBatchLink } from './httpBatchLink-d0f9eac9.mjs';\nimport { httpLinkFactory } from './links/httpLink.mjs';\nexport { httpLink, httpLinkFactory } from './links/httpLink.mjs';\nexport { loggerLink } from './links/loggerLink.mjs';\nexport { createWSClient, wsLink } from './links/wsLink.mjs';\nimport './transformResult-ace864b8.mjs';\n\nclass TRPCUntypedClient {\n    $request({ type , input , path , context ={}  }) {\n        const chain$ = createChain({\n            links: this.links,\n            op: {\n                id: ++this.requestId,\n                type,\n                path,\n                input,\n                context\n            }\n        });\n        return chain$.pipe(share());\n    }\n    requestAsPromise(opts) {\n        const req$ = this.$request(opts);\n        const { promise , abort  } = observableToPromise(req$);\n        const abortablePromise = new Promise((resolve, reject)=>{\n            opts.signal?.addEventListener('abort', abort);\n            promise.then((envelope)=>{\n                resolve(envelope.result.data);\n            }).catch((err)=>{\n                reject(TRPCClientError.from(err));\n            });\n        });\n        return abortablePromise;\n    }\n    query(path, input, opts) {\n        return this.requestAsPromise({\n            type: 'query',\n            path,\n            input,\n            context: opts?.context,\n            signal: opts?.signal\n        });\n    }\n    mutation(path, input, opts) {\n        return this.requestAsPromise({\n            type: 'mutation',\n            path,\n            input,\n            context: opts?.context,\n            signal: opts?.signal\n        });\n    }\n    subscription(path, input, opts) {\n        const observable$ = this.$request({\n            type: 'subscription',\n            path,\n            input,\n            context: opts?.context\n        });\n        return observable$.subscribe({\n            next (envelope) {\n                if (envelope.result.type === 'started') {\n                    opts.onStarted?.();\n                } else if (envelope.result.type === 'stopped') {\n                    opts.onStopped?.();\n                } else {\n                    opts.onData?.(envelope.result.data);\n                }\n            },\n            error (err) {\n                opts.onError?.(err);\n            },\n            complete () {\n                opts.onComplete?.();\n            }\n        });\n    }\n    constructor(opts){\n        this.requestId = 0;\n        const combinedTransformer = (()=>{\n            const transformer = opts.transformer;\n            if (!transformer) {\n                return {\n                    input: {\n                        serialize: (data)=>data,\n                        deserialize: (data)=>data\n                    },\n                    output: {\n                        serialize: (data)=>data,\n                        deserialize: (data)=>data\n                    }\n                };\n            }\n            if ('input' in transformer) {\n                return opts.transformer;\n            }\n            return {\n                input: transformer,\n                output: transformer\n            };\n        })();\n        this.runtime = {\n            transformer: {\n                serialize: (data)=>combinedTransformer.input.serialize(data),\n                deserialize: (data)=>combinedTransformer.output.deserialize(data)\n            },\n            combinedTransformer\n        };\n        // Initialize the links\n        this.links = opts.links.map((link)=>link(this.runtime));\n    }\n}\n\nfunction createTRPCUntypedClient(opts) {\n    return new TRPCUntypedClient(opts);\n}\n\n/**\n * @deprecated use `createTRPCProxyClient` instead\n */ function createTRPCClient(opts) {\n    const client = new TRPCUntypedClient(opts);\n    return client;\n}\n\nconst clientCallTypeMap = {\n    query: 'query',\n    mutate: 'mutation',\n    subscribe: 'subscription'\n};\n/** @internal */ const clientCallTypeToProcedureType = (clientCallType)=>{\n    return clientCallTypeMap[clientCallType];\n};\n/**\n * @deprecated use `createTRPCProxyClient` instead\n * @internal\n */ function createTRPCClientProxy(client) {\n    return createFlatProxy((key)=>{\n        if (client.hasOwnProperty(key)) {\n            return client[key];\n        }\n        if (key === '__untypedClient') {\n            return client;\n        }\n        return createRecursiveProxy(({ path , args  })=>{\n            const pathCopy = [\n                key,\n                ...path\n            ];\n            const procedureType = clientCallTypeToProcedureType(pathCopy.pop());\n            const fullPath = pathCopy.join('.');\n            return client[procedureType](fullPath, ...args);\n        });\n    });\n}\nfunction createTRPCProxyClient(opts) {\n    const client = new TRPCUntypedClient(opts);\n    const proxy = createTRPCClientProxy(client);\n    return proxy;\n}\n/**\n * Get an untyped client from a proxy client\n * @internal\n */ function getUntypedClient(client) {\n    return client.__untypedClient;\n}\n\nfunction getTextDecoder(customTextDecoder) {\n    if (customTextDecoder) {\n        return customTextDecoder;\n    }\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (typeof window !== 'undefined' && window.TextDecoder) {\n        return new window.TextDecoder();\n    }\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (typeof globalThis !== 'undefined' && globalThis.TextDecoder) {\n        return new globalThis.TextDecoder();\n    }\n    throw new Error('No TextDecoder implementation found');\n}\n\n// Stream parsing adapted from https://www.loginradius.com/blog/engineering/guest-post/http-streaming-with-nodejs-and-fetch-api/\n/**\n * @internal\n * @description Take a stream of bytes and call `onLine` with\n * a JSON object for each line in the stream. Expected stream\n * format is:\n * ```json\n * {\"1\": {...}\n * ,\"0\": {...}\n * }\n * ```\n */ async function parseJSONStream(opts) {\n    const parse = opts.parse ?? JSON.parse;\n    const onLine = (line)=>{\n        if (opts.signal?.aborted) return;\n        if (!line || line === '}') {\n            return;\n        }\n        /**\n     * At this point, `line` can be one of two things:\n     * - The first line of the stream `{\"2\":{...}`\n     * - A line in the middle of the stream `,\"2\":{...}`\n     */ const indexOfColon = line.indexOf(':');\n        const indexAsStr = line.substring(2, indexOfColon - 1);\n        const text = line.substring(indexOfColon + 1);\n        opts.onSingle(Number(indexAsStr), parse(text));\n    };\n    await readLines(opts.readableStream, onLine, opts.textDecoder);\n}\n/**\n * Handle transforming a stream of bytes into lines of text.\n * To avoid using AsyncIterators / AsyncGenerators,\n * we use a callback for each line.\n *\n * @param readableStream can be a NodeJS stream or a WebAPI stream\n * @param onLine will be called for every line ('\\n' delimited) in the stream\n */ async function readLines(readableStream, onLine, textDecoder) {\n    let partOfLine = '';\n    const onChunk = (chunk)=>{\n        const chunkText = textDecoder.decode(chunk);\n        const chunkLines = chunkText.split('\\n');\n        if (chunkLines.length === 1) {\n            partOfLine += chunkLines[0];\n        } else if (chunkLines.length > 1) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- length checked on line above\n            onLine(partOfLine + chunkLines[0]);\n            for(let i = 1; i < chunkLines.length - 1; i++){\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- length checked on line above\n                onLine(chunkLines[i]);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- length doesn't change, so is necessarily > 1\n            partOfLine = chunkLines[chunkLines.length - 1];\n        }\n    };\n    // we handle 2 different types of streams, this if where we figure out which one we have\n    if ('getReader' in readableStream) {\n        await readStandardChunks(readableStream, onChunk);\n    } else {\n        await readNodeChunks(readableStream, onChunk);\n    }\n    onLine(partOfLine);\n}\n/**\n * Handle NodeJS stream\n */ function readNodeChunks(stream, onChunk) {\n    return new Promise((resolve)=>{\n        stream.on('data', onChunk);\n        stream.on('end', resolve);\n    });\n}\n/**\n * Handle WebAPI stream\n */ async function readStandardChunks(stream, onChunk) {\n    const reader = stream.getReader();\n    let readResult = await reader.read();\n    while(!readResult.done){\n        onChunk(readResult.value);\n        readResult = await reader.read();\n    }\n}\nconst streamingJsonHttpRequester = (opts, onSingle)=>{\n    const ac = opts.AbortController ? new opts.AbortController() : null;\n    const responsePromise = fetchHTTPResponse({\n        ...opts,\n        contentTypeHeader: 'application/json',\n        batchModeHeader: 'stream',\n        getUrl,\n        getBody: getBody$1\n    }, ac);\n    const cancel = ()=>ac?.abort();\n    const promise = responsePromise.then(async (res)=>{\n        if (!res.body) throw new Error('Received response without body');\n        const meta = {\n            response: res\n        };\n        return parseJSONStream({\n            readableStream: res.body,\n            onSingle,\n            parse: (string)=>({\n                    json: JSON.parse(string),\n                    meta\n                }),\n            signal: ac?.signal,\n            textDecoder: opts.textDecoder\n        });\n    });\n    return {\n        cancel,\n        promise\n    };\n};\n\nconst streamRequester = (requesterOpts)=>{\n    const textDecoder = getTextDecoder(requesterOpts.opts.textDecoder);\n    return (batchOps, unitResolver)=>{\n        const path = batchOps.map((op)=>op.path).join(',');\n        const inputs = batchOps.map((op)=>op.input);\n        const { cancel , promise  } = streamingJsonHttpRequester({\n            ...requesterOpts,\n            textDecoder,\n            path,\n            inputs,\n            headers () {\n                if (!requesterOpts.opts.headers) {\n                    return {};\n                }\n                if (typeof requesterOpts.opts.headers === 'function') {\n                    return requesterOpts.opts.headers({\n                        opList: batchOps\n                    });\n                }\n                return requesterOpts.opts.headers;\n            }\n        }, (index, res)=>{\n            unitResolver(index, res);\n        });\n        return {\n            /**\n       * return an empty array because the batchLoader expects an array of results\n       * but we've already called the `unitResolver` for each of them, there's\n       * nothing left to do here.\n       */ promise: promise.then(()=>[]),\n            cancel\n        };\n    };\n};\nconst unstable_httpBatchStreamLink = createHTTPBatchLink(streamRequester);\n\nconst getBody = (opts)=>{\n    if (!('input' in opts)) {\n        return undefined;\n    }\n    if (!(opts.input instanceof FormData)) {\n        throw new Error('Input is not FormData');\n    }\n    return opts.input;\n};\nconst formDataRequester = (opts)=>{\n    if (opts.type !== 'mutation') {\n        // TODO(?) handle formdata queries\n        throw new Error('We only handle mutations with formdata');\n    }\n    return httpRequest({\n        ...opts,\n        getUrl () {\n            return `${opts.url}/${opts.path}`;\n        },\n        getBody\n    });\n};\nconst experimental_formDataLink = httpLinkFactory({\n    requester: formDataRequester\n});\n\nexport { TRPCUntypedClient, clientCallTypeToProcedureType, createTRPCClient, createTRPCClientProxy, createTRPCProxyClient, createTRPCUntypedClient, experimental_formDataLink, getUntypedClient, unstable_httpBatchStreamLink };\n","/**\n * To allow easy interactions with groups of related queries, such as\n * invalidating all queries of a router, we use an array as the path when\n * storing in tanstack query. This function converts from the `.` separated\n * path passed around internally by both the legacy and proxy implementation.\n * https://github.com/trpc/trpc/issues/2611\n **/ function getArrayQueryKey(queryKey, type) {\n    const queryKeyArrayed = Array.isArray(queryKey) ? queryKey : [\n        queryKey\n    ];\n    const [path, input] = queryKeyArrayed;\n    const arrayPath = typeof path !== 'string' || path === '' ? [] : path.split('.');\n    // Construct a query key that is easy to destructure and flexible for\n    // partial selecting etc.\n    // https://github.com/trpc/trpc/issues/3128\n    if (!input && (!type || type === 'any')) // for `utils.invalidate()` to match all queries (including vanilla react-query)\n    // we don't want nested array if path is empty, i.e. `[]` instead of `[[]]`\n    return arrayPath.length ? [\n        arrayPath\n    ] : [];\n    return [\n        arrayPath,\n        {\n            ...typeof input !== 'undefined' && {\n                input: input\n            },\n            ...type && type !== 'any' && {\n                type: type\n            }\n        }\n    ];\n}\n\nexport { getArrayQueryKey as g };\n","import { createRecursiveProxy, createFlatProxy } from '@trpc/server/shared';\nimport { g as getArrayQueryKey } from './getArrayQueryKey-86134f8b.mjs';\nimport { createTRPCClientProxy, createTRPCClient } from '@trpc/client';\nimport { useQuery, useQueryClient, useMutation, hashQueryKey, useInfiniteQuery, useQueries } from '@tanstack/react-query';\nimport React, { createContext, useMemo, useState, useEffect, useCallback, useRef } from 'react';\n\n/**\n * We treat `undefined` as an input the same as omitting an `input`\n * https://github.com/trpc/trpc/issues/2290\n */ function getQueryKeyInternal(path, input) {\n    if (path.length) return input === undefined ? [\n        path\n    ] : [\n        path,\n        input\n    ];\n    return [];\n}\n/**\n * Method to extract the query key for a procedure\n * @param procedureOrRouter - procedure or AnyRouter\n * @param input - input to procedureOrRouter\n * @param type - defaults to `any`\n * @link https://trpc.io/docs/getQueryKey\n */ function getQueryKey(..._params) {\n    const [procedureOrRouter, input, type] = _params;\n    // @ts-expect-error - we don't expose _def on the type layer\n    const path = procedureOrRouter._def().path;\n    const dotPath = path.join('.');\n    const queryKey = getArrayQueryKey(getQueryKeyInternal(dotPath, input), type ?? 'any');\n    return queryKey;\n}\n\n/**\n * Create proxy for decorating procedures\n * @internal\n */ function createReactProxyDecoration(name, hooks) {\n    return createRecursiveProxy((opts)=>{\n        const args = opts.args;\n        const pathCopy = [\n            name,\n            ...opts.path\n        ];\n        // The last arg is for instance `.useMutation` or `.useQuery()`\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const lastArg = pathCopy.pop();\n        // The `path` ends up being something like `post.byId`\n        const path = pathCopy.join('.');\n        if (lastArg === 'useMutation') {\n            return hooks[lastArg](path, ...args);\n        }\n        const [input, ...rest] = args;\n        const queryKey = getQueryKeyInternal(path, input);\n        // Expose queryKey helper\n        if (lastArg === 'getQueryKey') {\n            return getArrayQueryKey(queryKey, rest[0] ?? 'any');\n        }\n        if (lastArg === '_def') {\n            return {\n                path: pathCopy\n            };\n        }\n        if (lastArg.startsWith('useSuspense')) {\n            const opts1 = rest[0] || {};\n            const fn = lastArg === 'useSuspenseQuery' ? 'useQuery' : 'useInfiniteQuery';\n            const result = hooks[fn](queryKey, {\n                ...opts1,\n                suspense: true,\n                enabled: true\n            });\n            return [\n                result.data,\n                result\n            ];\n        }\n        return hooks[lastArg](queryKey, ...rest);\n    });\n}\n\nconst contextProps = [\n    'client',\n    'ssrContext',\n    'ssrState',\n    'abortOnUnmount'\n];\nconst TRPCContext = /*#__PURE__*/ createContext(null);\n\n/**\n * @internal\n */ function createReactQueryUtilsProxy(context) {\n    return createFlatProxy((key)=>{\n        const contextName = key;\n        if (contextName === 'client') {\n            return createTRPCClientProxy(context.client);\n        }\n        if (contextProps.includes(contextName)) {\n            return context[contextName];\n        }\n        return createRecursiveProxy(({ path , args  })=>{\n            const pathCopy = [\n                key,\n                ...path\n            ];\n            const utilName = pathCopy.pop();\n            const fullPath = pathCopy.join('.');\n            const getOpts = (name)=>{\n                if ([\n                    'setData',\n                    'setInfiniteData'\n                ].includes(name)) {\n                    const [input, updater, ...rest] = args;\n                    const queryKey = getQueryKeyInternal(fullPath, input);\n                    return {\n                        queryKey,\n                        updater,\n                        rest\n                    };\n                }\n                const [input1, ...rest1] = args;\n                const queryKey1 = getQueryKeyInternal(fullPath, input1);\n                return {\n                    queryKey: queryKey1,\n                    rest: rest1\n                };\n            };\n            const { queryKey , rest , updater  } = getOpts(utilName);\n            const contextMap = {\n                fetch: ()=>context.fetchQuery(queryKey, ...rest),\n                fetchInfinite: ()=>context.fetchInfiniteQuery(queryKey, ...rest),\n                prefetch: ()=>context.prefetchQuery(queryKey, ...rest),\n                prefetchInfinite: ()=>context.prefetchInfiniteQuery(queryKey, ...rest),\n                ensureData: ()=>context.ensureQueryData(queryKey, ...rest),\n                invalidate: ()=>context.invalidateQueries(queryKey, ...rest),\n                reset: ()=>context.resetQueries(queryKey, ...rest),\n                refetch: ()=>context.refetchQueries(queryKey, ...rest),\n                cancel: ()=>context.cancelQuery(queryKey, ...rest),\n                setData: ()=>{\n                    context.setQueryData(queryKey, updater, ...rest);\n                },\n                setInfiniteData: ()=>{\n                    context.setInfiniteQueryData(queryKey, updater, ...rest);\n                },\n                getData: ()=>context.getQueryData(queryKey),\n                getInfiniteData: ()=>context.getInfiniteQueryData(queryKey)\n            };\n            return contextMap[utilName]();\n        });\n    });\n}\n\n/**\n * Create proxy for `useQueries` options\n * @internal\n */ function createUseQueriesProxy(client) {\n    return createRecursiveProxy((opts)=>{\n        const path = opts.path.join('.');\n        const [input, _opts] = opts.args;\n        const queryKey = getQueryKeyInternal(path, input);\n        const options = {\n            queryKey,\n            queryFn: ()=>{\n                return client.query(path, input, _opts?.trpc);\n            },\n            ..._opts\n        };\n        return options;\n    });\n}\n\nfunction getClientArgs(pathAndInput, opts) {\n    const [path, input] = pathAndInput;\n    return [\n        path,\n        input,\n        opts?.trpc\n    ];\n}\n\n/**\n * Makes a stable reference of the `trpc` prop\n */ function useHookResult(value) {\n    const { path  } = value;\n    return useMemo(()=>({\n            path\n        }), [\n        path\n    ]);\n}\n\n/**\n * @internal\n */ function createRootHooks(config) {\n    const mutationSuccessOverride = (config?.overrides ?? config?.unstable_overrides)?.useMutation?.onSuccess ?? ((options)=>options.originalFn());\n    const Context = config?.context ?? TRPCContext;\n    const ReactQueryContext = config?.reactQueryContext;\n    const createClient = (opts)=>{\n        return createTRPCClient(opts);\n    };\n    const TRPCProvider = (props)=>{\n        const { abortOnUnmount =false , client , queryClient , ssrContext  } = props;\n        const [ssrState, setSSRState] = useState(props.ssrState ?? false);\n        useEffect(()=>{\n            // Only updating state to `mounted` if we are using SSR.\n            // This makes it so we don't have an unnecessary re-render when opting out of SSR.\n            setSSRState((state)=>state ? 'mounted' : false);\n        }, []);\n        return /*#__PURE__*/ React.createElement(Context.Provider, {\n            value: {\n                abortOnUnmount,\n                queryClient,\n                client,\n                ssrContext: ssrContext ?? null,\n                ssrState,\n                fetchQuery: useCallback((pathAndInput, opts)=>{\n                    return queryClient.fetchQuery({\n                        ...opts,\n                        queryKey: getArrayQueryKey(pathAndInput, 'query'),\n                        queryFn: ()=>client.query(...getClientArgs(pathAndInput, opts))\n                    });\n                }, [\n                    client,\n                    queryClient\n                ]),\n                fetchInfiniteQuery: useCallback((pathAndInput, opts)=>{\n                    return queryClient.fetchInfiniteQuery({\n                        ...opts,\n                        queryKey: getArrayQueryKey(pathAndInput, 'infinite'),\n                        queryFn: ({ pageParam  })=>{\n                            const [path, input] = pathAndInput;\n                            const actualInput = {\n                                ...input,\n                                cursor: pageParam\n                            };\n                            return client.query(...getClientArgs([\n                                path,\n                                actualInput\n                            ], opts));\n                        }\n                    });\n                }, [\n                    client,\n                    queryClient\n                ]),\n                prefetchQuery: useCallback((pathAndInput, opts)=>{\n                    return queryClient.prefetchQuery({\n                        ...opts,\n                        queryKey: getArrayQueryKey(pathAndInput, 'query'),\n                        queryFn: ()=>client.query(...getClientArgs(pathAndInput, opts))\n                    });\n                }, [\n                    client,\n                    queryClient\n                ]),\n                prefetchInfiniteQuery: useCallback((pathAndInput, opts)=>{\n                    return queryClient.prefetchInfiniteQuery({\n                        ...opts,\n                        queryKey: getArrayQueryKey(pathAndInput, 'infinite'),\n                        queryFn: ({ pageParam  })=>{\n                            const [path, input] = pathAndInput;\n                            const actualInput = {\n                                ...input,\n                                cursor: pageParam\n                            };\n                            return client.query(...getClientArgs([\n                                path,\n                                actualInput\n                            ], opts));\n                        }\n                    });\n                }, [\n                    client,\n                    queryClient\n                ]),\n                ensureQueryData: useCallback((pathAndInput, opts)=>{\n                    return queryClient.ensureQueryData({\n                        ...opts,\n                        queryKey: getArrayQueryKey(pathAndInput, 'query'),\n                        queryFn: ()=>client.query(...getClientArgs(pathAndInput, opts))\n                    });\n                }, [\n                    client,\n                    queryClient\n                ]),\n                invalidateQueries: useCallback((queryKey, filters, options)=>{\n                    return queryClient.invalidateQueries({\n                        ...filters,\n                        queryKey: getArrayQueryKey(queryKey, 'any')\n                    }, options);\n                }, [\n                    queryClient\n                ]),\n                resetQueries: useCallback((...args)=>{\n                    const [queryKey, filters, options] = args;\n                    return queryClient.resetQueries({\n                        ...filters,\n                        queryKey: getArrayQueryKey(queryKey, 'any')\n                    }, options);\n                }, [\n                    queryClient\n                ]),\n                refetchQueries: useCallback((...args)=>{\n                    const [queryKey, filters, options] = args;\n                    return queryClient.refetchQueries({\n                        ...filters,\n                        queryKey: getArrayQueryKey(queryKey, 'any')\n                    }, options);\n                }, [\n                    queryClient\n                ]),\n                cancelQuery: useCallback((pathAndInput)=>{\n                    return queryClient.cancelQueries({\n                        queryKey: getArrayQueryKey(pathAndInput, 'any')\n                    });\n                }, [\n                    queryClient\n                ]),\n                setQueryData: useCallback((...args)=>{\n                    const [queryKey, ...rest] = args;\n                    return queryClient.setQueryData(getArrayQueryKey(queryKey, 'query'), ...rest);\n                }, [\n                    queryClient\n                ]),\n                getQueryData: useCallback((...args)=>{\n                    const [queryKey, ...rest] = args;\n                    return queryClient.getQueryData(getArrayQueryKey(queryKey, 'query'), ...rest);\n                }, [\n                    queryClient\n                ]),\n                setInfiniteQueryData: useCallback((...args)=>{\n                    const [queryKey, ...rest] = args;\n                    return queryClient.setQueryData(getArrayQueryKey(queryKey, 'infinite'), ...rest);\n                }, [\n                    queryClient\n                ]),\n                getInfiniteQueryData: useCallback((...args)=>{\n                    const [queryKey, ...rest] = args;\n                    return queryClient.getQueryData(getArrayQueryKey(queryKey, 'infinite'), ...rest);\n                }, [\n                    queryClient\n                ])\n            }\n        }, props.children);\n    };\n    function useContext() {\n        return React.useContext(Context);\n    }\n    /**\n   * Hack to make sure errors return `status`='error` when doing SSR\n   * @link https://github.com/trpc/trpc/pull/1645\n   */ function useSSRQueryOptionsIfNeeded(pathAndInput, type, opts) {\n        const { queryClient , ssrState  } = useContext();\n        return ssrState && ssrState !== 'mounted' && queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput, type))?.state.status === 'error' ? {\n            retryOnMount: false,\n            ...opts\n        } : opts;\n    }\n    function useQuery$1(// FIXME path should be a tuple in next major\n    pathAndInput, opts) {\n        const context = useContext();\n        if (!context) {\n            throw new Error('Unable to retrieve application context. Did you forget to wrap your App inside `withTRPC` HoC?');\n        }\n        const { abortOnUnmount , client , ssrState , queryClient , prefetchQuery  } = context;\n        const defaultOpts = queryClient.getQueryDefaults(getArrayQueryKey(pathAndInput, 'query'));\n        if (typeof window === 'undefined' && ssrState === 'prepass' && opts?.trpc?.ssr !== false && (opts?.enabled ?? defaultOpts?.enabled) !== false && !queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput, 'query'))) {\n            void prefetchQuery(pathAndInput, opts);\n        }\n        const ssrOpts = useSSRQueryOptionsIfNeeded(pathAndInput, 'query', {\n            ...defaultOpts,\n            ...opts\n        });\n        const shouldAbortOnUnmount = opts?.trpc?.abortOnUnmount ?? config?.abortOnUnmount ?? abortOnUnmount;\n        const hook = useQuery({\n            ...ssrOpts,\n            queryKey: getArrayQueryKey(pathAndInput, 'query'),\n            queryFn: (queryFunctionContext)=>{\n                const actualOpts = {\n                    ...ssrOpts,\n                    trpc: {\n                        ...ssrOpts?.trpc,\n                        ...shouldAbortOnUnmount ? {\n                            signal: queryFunctionContext.signal\n                        } : {}\n                    }\n                };\n                return client.query(...getClientArgs(pathAndInput, actualOpts));\n            },\n            context: ReactQueryContext\n        });\n        hook.trpc = useHookResult({\n            path: pathAndInput[0]\n        });\n        return hook;\n    }\n    function useMutation$1(// FIXME: this should only be a tuple path in next major\n    path, opts) {\n        const { client  } = useContext();\n        const queryClient = useQueryClient({\n            context: ReactQueryContext\n        });\n        const actualPath = Array.isArray(path) ? path[0] : path;\n        const defaultOpts = queryClient.getMutationDefaults([\n            actualPath.split('.')\n        ]);\n        const hook = useMutation({\n            ...opts,\n            mutationKey: [\n                actualPath.split('.')\n            ],\n            mutationFn: (input)=>{\n                return client.mutation(...getClientArgs([\n                    actualPath,\n                    input\n                ], opts));\n            },\n            context: ReactQueryContext,\n            onSuccess (...args) {\n                const originalFn = ()=>opts?.onSuccess?.(...args) ?? defaultOpts?.onSuccess?.(...args);\n                return mutationSuccessOverride({\n                    originalFn,\n                    queryClient,\n                    meta: opts?.meta ?? defaultOpts?.meta ?? {}\n                });\n            }\n        });\n        hook.trpc = useHookResult({\n            path: actualPath\n        });\n        return hook;\n    }\n    /* istanbul ignore next -- @preserve */ function useSubscription(pathAndInput, opts) {\n        const enabled = opts?.enabled ?? true;\n        const queryKey = hashQueryKey(pathAndInput);\n        const { client  } = useContext();\n        const optsRef = useRef(opts);\n        optsRef.current = opts;\n        useEffect(()=>{\n            if (!enabled) {\n                return;\n            }\n            const [path, input] = pathAndInput;\n            let isStopped = false;\n            const subscription = client.subscription(path, input ?? undefined, {\n                onStarted: ()=>{\n                    if (!isStopped) {\n                        optsRef.current.onStarted?.();\n                    }\n                },\n                onData: (data)=>{\n                    if (!isStopped) {\n                        // FIXME this shouldn't be needed as both should be `unknown` in next major\n                        optsRef.current.onData(data);\n                    }\n                },\n                onError: (err)=>{\n                    if (!isStopped) {\n                        optsRef.current.onError?.(err);\n                    }\n                }\n            });\n            return ()=>{\n                isStopped = true;\n                subscription.unsubscribe();\n            };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            queryKey,\n            enabled\n        ]);\n    }\n    function useInfiniteQuery$1(pathAndInput, opts) {\n        const [path, input] = pathAndInput;\n        const { client , ssrState , prefetchInfiniteQuery , queryClient , abortOnUnmount ,  } = useContext();\n        const defaultOpts = queryClient.getQueryDefaults(getArrayQueryKey(pathAndInput, 'infinite'));\n        if (typeof window === 'undefined' && ssrState === 'prepass' && opts?.trpc?.ssr !== false && (opts?.enabled ?? defaultOpts?.enabled) !== false && !queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput, 'infinite'))) {\n            void prefetchInfiniteQuery(pathAndInput, {\n                ...defaultOpts,\n                ...opts\n            });\n        }\n        const ssrOpts = useSSRQueryOptionsIfNeeded(pathAndInput, 'infinite', {\n            ...defaultOpts,\n            ...opts\n        });\n        // request option should take priority over global\n        const shouldAbortOnUnmount = opts?.trpc?.abortOnUnmount ?? abortOnUnmount;\n        const hook = useInfiniteQuery({\n            ...ssrOpts,\n            queryKey: getArrayQueryKey(pathAndInput, 'infinite'),\n            queryFn: (queryFunctionContext)=>{\n                const actualOpts = {\n                    ...ssrOpts,\n                    trpc: {\n                        ...ssrOpts?.trpc,\n                        ...shouldAbortOnUnmount ? {\n                            signal: queryFunctionContext.signal\n                        } : {}\n                    }\n                };\n                const actualInput = {\n                    ...input ?? {},\n                    cursor: queryFunctionContext.pageParam ?? opts?.initialCursor\n                };\n                // FIXME as any shouldn't be needed as client should be untyped too\n                return client.query(...getClientArgs([\n                    path,\n                    actualInput\n                ], actualOpts));\n            },\n            context: ReactQueryContext\n        });\n        hook.trpc = useHookResult({\n            path\n        });\n        return hook;\n    }\n    const useQueries$1 = (queriesCallback, context)=>{\n        const { ssrState , queryClient , prefetchQuery , client  } = useContext();\n        const proxy = createUseQueriesProxy(client);\n        const queries = queriesCallback(proxy);\n        if (typeof window === 'undefined' && ssrState === 'prepass') {\n            for (const query of queries){\n                const queryOption = query;\n                if (queryOption.trpc?.ssr !== false && !queryClient.getQueryCache().find(getArrayQueryKey(queryOption.queryKey, 'query'))) {\n                    void prefetchQuery(queryOption.queryKey, queryOption);\n                }\n            }\n        }\n        return useQueries({\n            queries: queries.map((query)=>({\n                    ...query,\n                    queryKey: getArrayQueryKey(query.queryKey, 'query')\n                })),\n            context\n        });\n    };\n    const useDehydratedState = (client, trpcState)=>{\n        const transformed = useMemo(()=>{\n            if (!trpcState) {\n                return trpcState;\n            }\n            return client.runtime.transformer.deserialize(trpcState);\n        }, [\n            trpcState,\n            client\n        ]);\n        return transformed;\n    };\n    return {\n        Provider: TRPCProvider,\n        createClient,\n        useContext,\n        useUtils: useContext,\n        useQuery: useQuery$1,\n        useQueries: useQueries$1,\n        useMutation: useMutation$1,\n        useSubscription,\n        useDehydratedState,\n        useInfiniteQuery: useInfiniteQuery$1\n    };\n}\n\n/**\n * Create strongly typed react hooks\n * @internal\n * @deprecated\n */ function createHooksInternal(config) {\n    return createRootHooks(config);\n}\n\nexport { TRPCContext as T, createReactQueryUtilsProxy as a, createReactProxyDecoration as b, createHooksInternal as c, getClientArgs as d, createUseQueriesProxy as e, createRootHooks as f, getQueryKey as g, contextProps as h };\n","export * from '@trpc/client';\nimport { c as createHooksInternal, a as createReactQueryUtilsProxy, b as createReactProxyDecoration } from './createHooksInternal-063195fc.mjs';\nexport { g as getQueryKey } from './createHooksInternal-063195fc.mjs';\nimport { createFlatProxy } from '@trpc/server/shared';\nimport { useMemo } from 'react';\nimport '@tanstack/react-query';\nimport './getArrayQueryKey-86134f8b.mjs';\n\n/**\n * @internal\n */ function createHooksInternalProxy(trpc) {\n    return createFlatProxy((key)=>{\n        if (key === 'useContext' || key === 'useUtils') {\n            return ()=>{\n                const context = trpc.useUtils();\n                // create a stable reference of the utils context\n                return useMemo(()=>{\n                    return createReactQueryUtilsProxy(context);\n                }, [\n                    context\n                ]);\n            };\n        }\n        if (trpc.hasOwnProperty(key)) {\n            return trpc[key];\n        }\n        return createReactProxyDecoration(key, trpc);\n    });\n}\nfunction createTRPCReact(opts) {\n    const hooks = createHooksInternal(opts);\n    const proxy = createHooksInternalProxy(hooks);\n    return proxy;\n}\n\n// interop:\n/**\n * @deprecated use `createTRPCReact` instead\n */ function createReactQueryHooks(opts) {\n    const trpc = createHooksInternal(opts);\n    const proxy = createHooksInternalProxy(trpc);\n    return {\n        ...trpc,\n        proxy\n    };\n}\n\nexport { createReactQueryHooks, createTRPCReact };\n"],"names":["Subscribable","listener","identity","isServer","noop","functionalUpdate","updater","input","isValidTimeout","value","difference","array1","array2","x","replaceAt","array","index","copy","timeUntilStale","updatedAt","staleTime","parseQueryArgs","arg1","arg2","arg3","isQueryKey","parseMutationArgs","parseFilterArgs","matchQuery","filters","query","type","exact","fetchStatus","predicate","queryKey","stale","hashQueryKeyByOptions","partialMatchKey","isActive","matchMutation","mutation","fetching","mutationKey","hashQueryKey","options","_","val","isPlainObject","result","key","a","b","partialDeepEqual","replaceEqualDeep","isPlainArray","aSize","bItems","bSize","equalItems","i","shallowEqualObjects","o","hasObjectPrototype","ctor","prot","sleep","timeout","resolve","scheduleMicrotask","callback","getAbortController","replaceData","prevData","data","FocusManager","onFocus","_this$cleanup","setup","_this$cleanup2","focused","focusManager","onlineEvents","OnlineManager","onOnline","event","online","onlineManager","defaultRetryDelay","failureCount","canFetch","networkMode","CancelledError","isCancelledError","createRetryer","config","isRetryCancelled","isResolved","continueFn","promiseResolve","promiseReject","promise","outerResolve","outerReject","cancel","cancelOptions","reject","cancelRetry","continueRetry","shouldPause","pause","continueResolve","canContinue","run","promiseOrValue","error","_config$retry","_config$retryDelay","retry","retryDelay","delay","shouldRetry","defaultLogger","createNotifyManager","queue","transactions","notifyFn","batchNotifyFn","batch","flush","schedule","batchCalls","args","originalQueue","fn","notifyManager","Removable","newCacheTime","Query","getDefaultState","newData","state","setStateOptions","_this$retryer","observer","_this$retryer2","_this$retryer3","fetchOptions","_this$options$behavio","_context$fetchOptions","_this$retryer4","abortController","queryFnContext","addSignalProperty","object","fetchFn","context","_context$fetchOptions2","onError","_this$cache$config$on","_this$cache$config","_this$cache$config$on2","_this$cache$config2","_this$cache$config$on3","_this$cache$config3","_this$cache$config$on4","_this$cache$config4","action","reducer","_action$meta","_action$dataUpdatedAt","hasData","initialDataUpdatedAt","QueryCache","client","_options$queryHash","queryHash","queryInMap","Mutation","_this$retryer$continu","executeMutation","_this$options$retry","restored","_this$mutationCache$c3","_this$mutationCache$c4","_this$options$onSucce","_this$options2","_this$mutationCache$c5","_this$mutationCache$c6","_this$options$onSettl","_this$options3","_this$mutationCache$c","_this$mutationCache$c2","_this$options$onMutat","_this$options","_this$mutationCache$c7","_this$mutationCache$c8","_this$options$onError","_this$options4","_this$mutationCache$c9","_this$mutationCache$c10","_this$options$onSettl2","_this$options5","MutationCache","_this$resuming","pausedMutations","infiniteQueryBehavior","_context$fetchOptions3","_context$fetchOptions4","_context$state$data","_context$state$data2","refetchPage","fetchMore","pageParam","isFetchingNextPage","isFetchingPreviousPage","oldPages","oldPageParams","newPageParams","cancelled","_context$signal","_context$signal2","queryFn","buildNewPages","pages","param","page","previous","fetchPage","manual","queryFnResult","getNextPageParam","getPreviousPageParam","hasNextPage","nextPageParam","hasPreviousPage","previousPageParam","QueryClient","_this$unsubscribeFocu","_this$unsubscribeOnli","_this$queryCache$find","parsedOptions","cachedData","queryKeyOrFilters","defaultedOptions","_this$queryCache$find2","queryCache","refetchFilters","promises","_ref","_filters$refetchType","_options$cancelRefetc","firstMatchingDefaults","QueryObserver","shouldFetchOnMount","shouldFetchOn","notifyOptions","prevOptions","prevQuery","mounted","shouldFetchOptionally","nextRefetchInterval","shouldAssignObserverCurrentProperties","trackedResult","_fetchOptions$cancelR","_this$options$refetch","nextInterval","prevResult","prevResultState","prevResultOptions","queryChange","queryInitialState","prevQueryResult","dataUpdatedAt","errorUpdatedAt","status","isPreviousData","isPlaceholderData","fetchOnMount","fetchOptionally","selectError","placeholderData","isFetching","isLoading","isError","isStale","nextResult","defaultNotifyOptions","shouldNotifyListeners","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","typedKey","shouldLoadOnMount","field","optimisticResult","QueriesObserver","queries","prevObservers","newObserverMatches","match","newObservers","newObserversMap","newResult","hasIndexChange","prevObserversMap","defaultedQueryOptions","matchingObservers","matchedQueryHashes","unmatchedQueries","matchingObserversSet","unmatchedObservers","prevObserver","getObserver","currentObserver","newOrReusedObservers","previouslyUsedObserver","sortMatchesByOrderOfQueries","InfiniteQueryObserver","_state$fetchMeta","_state$fetchMeta$fetc","_state$fetchMeta2","_state$fetchMeta2$fet","_state$data","_state$data2","isRefetching","MutationObserver","_this$currentMutation","_this$currentMutation2","variables","_this$mutateOptions$o","_this$mutateOptions","_this$mutateOptions$o2","_this$mutateOptions2","_this$mutateOptions$o3","_this$mutateOptions3","_this$mutateOptions$o4","_this$mutateOptions4","is","y","useSyncExternalStore$2","subscribe","getSnapshot","didWarnOld18Alpha","React","didWarnUncachedGetSnapshot","cachedValue","objectIs","useState","inst","forceUpdate","useLayoutEffect","checkIfSnapshotChanged","useEffect","useDebugValue","latestGetSnapshot","nextValue","useSyncExternalStore$1","require$$0","shim","useSyncExternalStoreShim_development","shimModule","useSyncExternalStore","defaultContext","React.createContext","QueryClientSharingContext","getQueryClientContext","contextSharing","useQueryClient","queryClient","React.useContext","QueryClientProvider","children","React.useEffect","Context","React.createElement","IsRestoringContext","useIsRestoring","createValue","isReset","QueryErrorResetBoundaryContext","useQueryErrorResetBoundary","shouldThrowError","_useErrorBoundary","params","ensurePreventErrorBoundaryRetry","errorResetBoundary","useClearResetErrorBoundary","getHasError","useErrorBoundary","ensureStaleTime","willFetch","isRestoring","shouldSuspend","fetchOptimistic","useQueries","defaultedQueries","React.useMemo","React.useState","React.useCallback","onStoreChange","suspensePromises","queryObserver","observerQueries","firstSingleResultWhichShouldThrow","_defaultedQueries$ind","_defaultedQueries$ind2","useBaseQuery","Observer","unsubscribe","useQuery","useMutation","mutate","mutateOptions","useInfiniteQuery","pipeFromArray","fns","prev","observable","self","teardownRef","isDone","unsubscribed","teardownImmediately","_a","err","operations","share","_opts","originalObserver","refCount","subscription","observers","startIfNeeded","resetIfNeeded","_sub","v","ObservableAbortError","message","observableToPromise","abort","onDone","obs$","createChain","opts","execute","op","next","nextOp","asArray","splitLink","runtime","yes","link","no","props","links","invert","obj","newObj","TRPC_ERROR_CODES_BY_KEY","createInnerProxy","path","_obj","_1","_2","isApply","createRecursiveProxy","createFlatProxy","name","isObject","UnknownCauseError","getCauseFromUnknown","cause","transformResultInner","response","TransformResultError","transformResult","isTRPCClientError","TRPCClientError","isTRPCErrorResponse","_cause","_b","isFunction","getFetch","customFetchImpl","customAbortControllerImpl","resolveHTTPLinkOptions","arrayToDict","dict","element","METHOD","getInput","_input","getUrl","url","queryParts","getBody","jsonHttpRequester","httpRequest","fetchHTTPResponse","ac","body","resolvedHeaders","headers","meta","done","_res","json","throwFatalError","dataLoader","batchLoader","pendingItems","dispatchTimer","destroyTimerAndPendingItems","groupItems","items","groupedItems","item","lastGroup","it","dispatch","unitResolver","_item","load","createHTTPBatchLink","requester","resolvedOpts","maxURLLength","validate","batchOps","inputs","fetch","loaders","loader","res","transformed","batchRequester","requesterOpts","httpBatchLink","attemptIndex","createWSClient","WebSocketImpl","retryDelayFn","onOpen","onClose","outgoing","pendingRequests","connectAttempt","connectTimer","activeConnection","createWS","tryReconnect","reconnectInMs","reconnect","oldConnection","closeIfNoPending","ms","conn","p","closeActiveSubscriptions","req","resumeSubscriptionOnReconnect","r","request","urlString","handleIncomingRequest","pendingReq","handleIncomingResponse","oldWs","msg","code","_d","_c","TRPCWebSocketClosedError","callbacks","id","envelope","wsLink","unsub","TRPCUntypedClient","req$","combinedTransformer","transformer","createTRPCClient","clientCallTypeMap","clientCallTypeToProcedureType","clientCallType","createTRPCClientProxy","pathCopy","procedureType","fullPath","getArrayQueryKey","queryKeyArrayed","arrayPath","getQueryKeyInternal","createReactProxyDecoration","hooks","lastArg","rest","opts1","contextProps","TRPCContext","createContext","createReactQueryUtilsProxy","contextName","utilName","getOpts","input1","rest1","createUseQueriesProxy","getClientArgs","pathAndInput","useHookResult","useMemo","createRootHooks","mutationSuccessOverride","ReactQueryContext","createClient","TRPCProvider","abortOnUnmount","ssrContext","ssrState","setSSRState","useCallback","actualInput","useContext","useSSRQueryOptionsIfNeeded","useQuery$1","prefetchQuery","defaultOpts","ssrOpts","shouldAbortOnUnmount","hook","queryFunctionContext","actualOpts","useMutation$1","actualPath","useSubscription","enabled","optsRef","useRef","isStopped","useInfiniteQuery$1","prefetchInfiniteQuery","queriesCallback","proxy","queryOption","trpcState","createHooksInternal","createHooksInternalProxy","trpc","createTRPCReact"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46]}