/**
 * Real-Time Updates Hook
 * Manages real-time data synchronization with intelligent conflict resolution
 * and background sync capabilities for the Walmart Grocery Agent
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import { useWalmartWebSocket } from './useWalmartWebSocket';
import { walmartCacheService } from '../services/WalmartCacheService';
import { WalmartProduct, CartItem, PriceAlert, WSMessage } from '../components/Walmart/types/WalmartTypes';

interface UseRealtimeUpdatesOptions {
  productIds?: string[];
  categories?: string[];
  priceAlerts?: boolean;
  cartSync?: boolean;
  enablePush?: boolean;
  syncInterval?: number; // Background sync interval in ms
  retryAttempts?: number;
  retryDelay?: number;
}

interface PendingUpdate {
  id: string;
  type: 'product' | 'cart' | 'price' | 'alert';
  action: 'create' | 'update' | 'delete';
  data: any;
  timestamp: number;
  attempts: number;
}

interface SyncStatus {
  isOnline: boolean;
  lastSync: Date | null;
  pendingUpdates: number;
  syncInProgress: boolean;
  lastError: string | null;
}

interface ConflictResolution {
  strategy: 'client-wins' | 'server-wins' | 'manual' | 'merge';
  resolver?: (clientData: any, serverData: any) => any;
}

export const useRealtimeUpdates = (options: UseRealtimeUpdatesOptions = {}) => {
  const {
    productIds = [],
    categories = [],
    priceAlerts = true,
    cartSync = true,
    enablePush = false,
    syncInterval = 30000, // 30 seconds
    retryAttempts = 3,
    retryDelay = 1000
  } = options;\n  \n  // State\n  const [syncStatus, setSyncStatus] = useState<SyncStatus>({\n    isOnline: navigator.onLine,\n    lastSync: null,\n    pendingUpdates: 0,\n    syncInProgress: false,\n    lastError: null\n  });\n  \n  const [pendingUpdates, setPendingUpdates] = useState<PendingUpdate[]>([]);\n  const [conflicts, setConflicts] = useState<any[]>([]);\n  const [priceUpdates, setPriceUpdates] = useState<Map<string, number>>(new Map());\n  const [productUpdates, setProductUpdates] = useState<Map<string, WalmartProduct>>(new Map());\n  \n  // Refs\n  const syncIntervalRef = useRef<NodeJS.Timeout>();\n  const retryTimeoutRef = useRef<NodeJS.Timeout>();\n  const isInitializedRef = useRef(false);\n  const conflictResolvers = useRef<Map<string, ConflictResolution>>(new Map());\n  \n  // WebSocket connection\n  const {\n    isConnected,\n    sendMessage,\n    lastMessage,\n    connect,\n    disconnect\n  } = useWalmartWebSocket({\n    autoConnect: true,\n    userId: 'current-user' // Should come from auth context\n  });\n  \n  /**\n   * Update online status\n   */\n  const updateOnlineStatus = useCallback(() => {\n    const isOnline = navigator.onLine && isConnected;\n    setSyncStatus(prev => ({\n      ...prev,\n      isOnline,\n      lastError: isOnline ? null : prev.lastError\n    }));\n    \n    if (isOnline && pendingUpdates.length > 0) {\n      // Process pending updates when back online\n      processPendingUpdates();\n    }\n  }, [isConnected, pendingUpdates.length]);\n  \n  /**\n   * Add pending update to queue\n   */\n  const addPendingUpdate = useCallback((update: Omit<PendingUpdate, 'id' | 'timestamp' | 'attempts'>) => {\n    const pendingUpdate: PendingUpdate = {\n      ...update,\n      id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      timestamp: Date.now(),\n      attempts: 0\n    };\n    \n    setPendingUpdates(prev => {\n      const newUpdates = [...prev, pendingUpdate];\n      setSyncStatus(current => ({ ...current, pendingUpdates: newUpdates.length }));\n      return newUpdates;\n    });\n    \n    // Store in cache for persistence\n    walmartCacheService.set(`pending_update_${pendingUpdate.id}`, pendingUpdate, 24 * 60 * 60 * 1000); // 24 hours\n    \n    return pendingUpdate.id;\n  }, []);\n  \n  /**\n   * Remove pending update\n   */\n  const removePendingUpdate = useCallback((updateId: string) => {\n    setPendingUpdates(prev => {\n      const newUpdates = prev.filter(update => update.id !== updateId);\n      setSyncStatus(current => ({ ...current, pendingUpdates: newUpdates.length }));\n      return newUpdates;\n    });\n    \n    // Remove from cache\n    walmartCacheService.delete(`pending_update_${updateId}`);\n  }, []);\n  \n  /**\n   * Process pending updates\n   */\n  const processPendingUpdates = useCallback(async () => {\n    if (!syncStatus.isOnline || syncStatus.syncInProgress || pendingUpdates.length === 0) {\n      return;\n    }\n    \n    setSyncStatus(prev => ({ ...prev, syncInProgress: true, lastError: null }));\n    \n    try {\n      const updatePromises = pendingUpdates.map(async (update) => {\n        try {\n          await processUpdate(update);\n          removePendingUpdate(update.id);\n        } catch (error) {\n          update.attempts++;\n          \n          if (update.attempts >= retryAttempts) {\n            console.error(`Failed to sync update ${update.id} after ${retryAttempts} attempts:`, error);\n            removePendingUpdate(update.id);\n          } else {\n            // Retry with exponential backoff\n            const delay = retryDelay * Math.pow(2, update.attempts - 1);\n            setTimeout(() => {\n              // Update will be retried in next sync cycle\n            }, delay);\n          }\n        }\n      });\n      \n      await Promise.allSettled(updatePromises);\n      \n      setSyncStatus(prev => ({\n        ...prev,\n        syncInProgress: false,\n        lastSync: new Date()\n      }));\n      \n    } catch (error) {\n      setSyncStatus(prev => ({\n        ...prev,\n        syncInProgress: false,\n        lastError: error instanceof Error ? error.message : 'Sync failed'\n      }));\n    }\n  }, [syncStatus.isOnline, syncStatus.syncInProgress, pendingUpdates, retryAttempts, retryDelay]);\n  \n  /**\n   * Process individual update\n   */\n  const processUpdate = useCallback(async (update: PendingUpdate) => {\n    const message: WSMessage = {\n      type: `${update.type}_${update.action}` as any,\n      data: update.data,\n      timestamp: new Date().toISOString()\n    };\n    \n    const success = sendMessage(message);\n    if (!success) {\n      throw new Error('Failed to send update via WebSocket');\n    }\n    \n    // Wait for confirmation or timeout\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Update timeout'));\n      }, 10000);\n      \n      // This would typically be handled by WebSocket message handlers\n      // For now, we'll assume success\n      clearTimeout(timeout);\n      resolve(true);\n    });\n  }, [sendMessage]);\n  \n  /**\n   * Handle WebSocket messages\n   */\n  const handleWebSocketMessage = useCallback((message: WSMessage) => {\n    switch (message.type) {\n      case 'price_update':\n        if (priceAlerts) {\n          const { productId, newPrice, oldPrice } = message.data;\n          setPriceUpdates(prev => new Map(prev.set(productId, newPrice)));\n          \n          // Update cache\n          walmartCacheService.getProduct(productId).then(product => {\n            if (product) {\n              product.price = newPrice;\n              walmartCacheService.setProduct(product);\n            }\n          });\n          \n          // Show push notification if enabled\n          if (enablePush && 'Notification' in window) {\n            showPriceUpdateNotification(productId, oldPrice, newPrice);\n          }\n        }\n        break;\n        \n      case 'product_update':\n        const updatedProduct = message.data as WalmartProduct;\n        setProductUpdates(prev => new Map(prev.set(updatedProduct.id, updatedProduct)));\n        \n        // Update cache\n        walmartCacheService.setProduct(updatedProduct);\n        break;\n        \n      case 'cart_update':\n        if (cartSync) {\n          handleCartUpdate(message.data);\n        }\n        break;\n        \n      case 'conflict':\n        handleConflict(message.data);\n        break;\n    }\n  }, [priceAlerts, cartSync, enablePush]);\n  \n  /**\n   * Handle cart updates\n   */\n  const handleCartUpdate = useCallback((cartData: any) => {\n    // Emit custom event for cart components to listen to\n    window.dispatchEvent(new CustomEvent('walmart-cart-update', {\n      detail: cartData\n    }));\n  }, []);\n  \n  /**\n   * Handle conflicts\n   */\n  const handleConflict = useCallback((conflictData: any) => {\n    const resolver = conflictResolvers.current.get(conflictData.type);\n    \n    if (resolver) {\n      switch (resolver.strategy) {\n        case 'client-wins':\n          // Keep client data, ignore server data\n          break;\n          \n        case 'server-wins':\n          // Accept server data, update client\n          applyServerData(conflictData);\n          break;\n          \n        case 'merge':\n          if (resolver.resolver) {\n            const mergedData = resolver.resolver(conflictData.clientData, conflictData.serverData);\n            applyMergedData(conflictData.type, mergedData);\n          }\n          break;\n          \n        case 'manual':\n        default:\n          // Add to conflicts list for manual resolution\n          setConflicts(prev => [...prev, conflictData]);\n          break;\n      }\n    } else {\n      setConflicts(prev => [...prev, conflictData]);\n    }\n  }, []);\n  \n  /**\n   * Apply server data in conflict resolution\n   */\n  const applyServerData = useCallback((conflictData: any) => {\n    switch (conflictData.type) {\n      case 'product':\n        setProductUpdates(prev => new Map(prev.set(conflictData.id, conflictData.serverData)));\n        walmartCacheService.setProduct(conflictData.serverData);\n        break;\n        \n      case 'cart':\n        handleCartUpdate(conflictData.serverData);\n        break;\n    }\n  }, [handleCartUpdate]);\n  \n  /**\n   * Apply merged data in conflict resolution\n   */\n  const applyMergedData = useCallback((type: string, mergedData: any) => {\n    switch (type) {\n      case 'product':\n        setProductUpdates(prev => new Map(prev.set(mergedData.id, mergedData)));\n        walmartCacheService.setProduct(mergedData);\n        break;\n        \n      case 'cart':\n        handleCartUpdate(mergedData);\n        break;\n    }\n  }, [handleCartUpdate]);\n  \n  /**\n   * Show price update notification\n   */\n  const showPriceUpdateNotification = useCallback((productId: string, oldPrice: number, newPrice: number) => {\n    if (Notification.permission === 'granted') {\n      const priceChange = newPrice - oldPrice;\n      const changeText = priceChange > 0 ? 'increased' : 'decreased';\n      const changeAmount = Math.abs(priceChange).toFixed(2);\n      \n      new Notification('Price Alert', {\n        body: `Price ${changeText} by $${changeAmount}`,\n        icon: '/walmart-icon.png',\n        tag: `price-${productId}`,\n        renotify: true\n      });\n    }\n  }, []);\n  \n  /**\n   * Subscribe to product updates\n   */\n  const subscribeToProducts = useCallback((ids: string[]) => {\n    if (isConnected && ids.length > 0) {\n      sendMessage({\n        type: 'subscribe_products',\n        data: { productIds: ids },\n        timestamp: new Date().toISOString()\n      });\n    }\n  }, [isConnected, sendMessage]);\n  \n  /**\n   * Subscribe to category updates\n   */\n  const subscribeToCategories = useCallback((cats: string[]) => {\n    if (isConnected && cats.length > 0) {\n      sendMessage({\n        type: 'subscribe_categories',\n        data: { categories: cats },\n        timestamp: new Date().toISOString()\n      });\n    }\n  }, [isConnected, sendMessage]);\n  \n  /**\n   * Manually trigger sync\n   */\n  const syncNow = useCallback(async () => {\n    await processPendingUpdates();\n  }, [processPendingUpdates]);\n  \n  /**\n   * Pause sync\n   */\n  const pauseSync = useCallback(() => {\n    if (syncIntervalRef.current) {\n      clearInterval(syncIntervalRef.current);\n      syncIntervalRef.current = undefined;\n    }\n  }, []);\n  \n  /**\n   * Resume sync\n   */\n  const resumeSync = useCallback(() => {\n    if (!syncIntervalRef.current) {\n      syncIntervalRef.current = setInterval(processPendingUpdates, syncInterval);\n    }\n  }, [processPendingUpdates, syncInterval]);\n  \n  /**\n   * Set conflict resolver\n   */\n  const setConflictResolver = useCallback((type: string, resolver: ConflictResolution) => {\n    conflictResolvers.current.set(type, resolver);\n  }, []);\n  \n  /**\n   * Resolve conflict manually\n   */\n  const resolveConflict = useCallback((conflictId: string, resolution: 'client' | 'server' | any) => {\n    setConflicts(prev => {\n      const conflict = prev.find(c => c.id === conflictId);\n      if (!conflict) return prev;\n      \n      if (resolution === 'client') {\n        // Keep client data\n      } else if (resolution === 'server') {\n        applyServerData(conflict);\n      } else {\n        // Apply custom resolution\n        applyMergedData(conflict.type, resolution);\n      }\n      \n      return prev.filter(c => c.id !== conflictId);\n    });\n  }, [applyServerData, applyMergedData]);\n  \n  /**\n   * Load pending updates from cache on mount\n   */\n  useEffect(() => {\n    const loadPendingUpdates = async () => {\n      // This would load pending updates from IndexedDB cache\n      // Implementation depends on cache structure\n    };\n    \n    loadPendingUpdates();\n  }, []);\n  \n  /**\n   * Handle WebSocket messages\n   */\n  useEffect(() => {\n    if (lastMessage) {\n      handleWebSocketMessage(lastMessage);\n    }\n  }, [lastMessage, handleWebSocketMessage]);\n  \n  /**\n   * Update online status\n   */\n  useEffect(() => {\n    updateOnlineStatus();\n  }, [isConnected, updateOnlineStatus]);\n  \n  /**\n   * Subscribe to products and categories on connection\n   */\n  useEffect(() => {\n    if (isConnected && !isInitializedRef.current) {\n      subscribeToProducts(productIds);\n      subscribeToCategories(categories);\n      isInitializedRef.current = true;\n    }\n  }, [isConnected, productIds, categories, subscribeToProducts, subscribeToCategories]);\n  \n  /**\n   * Set up background sync interval\n   */\n  useEffect(() => {\n    resumeSync();\n    \n    return () => {\n      pauseSync();\n    };\n  }, [resumeSync, pauseSync]);\n  \n  /**\n   * Handle online/offline events\n   */\n  useEffect(() => {\n    const handleOnline = () => updateOnlineStatus();\n    const handleOffline = () => updateOnlineStatus();\n    \n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n    \n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, [updateOnlineStatus]);\n  \n  /**\n   * Request notification permission if push notifications enabled\n   */\n  useEffect(() => {\n    if (enablePush && 'Notification' in window && Notification.permission === 'default') {\n      Notification.requestPermission();\n    }\n  }, [enablePush]);\n  \n  /**\n   * Cleanup on unmount\n   */\n  useEffect(() => {\n    return () => {\n      pauseSync();\n      if (retryTimeoutRef.current) {\n        clearTimeout(retryTimeoutRef.current);\n      }\n    };\n  }, [pauseSync]);\n  \n  return {\n    // Status\n    isOnline: syncStatus.isOnline,\n    lastSync: syncStatus.lastSync,\n    pendingUpdates: syncStatus.pendingUpdates,\n    syncInProgress: syncStatus.syncInProgress,\n    lastError: syncStatus.lastError,\n    \n    // Updates\n    priceUpdates,\n    productUpdates,\n    conflicts,\n    \n    // Actions\n    syncNow,\n    pauseSync,\n    resumeSync,\n    addPendingUpdate,\n    subscribeToProducts,\n    subscribeToCategories,\n    setConflictResolver,\n    resolveConflict,\n    \n    // Connection management\n    connect,\n    disconnect\n  };\n};"