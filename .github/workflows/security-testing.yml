name: Security Testing

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  schedule:
    # Run security tests every day at 1 AM UTC
    - cron: '0 1 * * *'
  workflow_dispatch:

jobs:
  authentication-testing:
    name: Authentication Security Testing
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - uses: pnpm/action-setup@v4
        with:
          version: 9
          
      - uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "pnpm"
          
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        
      - name: Create authentication security tests
        run: |
          mkdir -p security-tests/auth
          cat > security-tests/auth/auth-tests.js << 'EOF'
          const http = require('http');
          const crypto = require('crypto');
          
          class AuthSecurityTester {
            constructor(baseUrl = 'http://localhost:3000') {
              this.baseUrl = baseUrl;
              this.results = [];
            }
            
            async makeRequest(path, method = 'GET', data = null, headers = {}) {
              return new Promise((resolve, reject) => {
                const options = {
                  hostname: 'localhost',
                  port: 3000,
                  path: path,
                  method: method,
                  headers: {
                    'Content-Type': 'application/json',
                    ...headers
                  }
                };
                
                const req = http.request(options, (res) => {
                  let responseData = '';
                  res.on('data', chunk => responseData += chunk);
                  res.on('end', () => {
                    resolve({ 
                      status: res.statusCode, 
                      headers: res.headers,
                      data: responseData 
                    });
                  });
                });
                
                req.on('error', reject);
                
                if (data) {
                  req.write(JSON.stringify(data));
                }
                
                req.end();
              });
            }
            
            async testWeakPasswords() {
              const weakPasswords = [
                'password',
                '123456',
                'admin',
                'root',
                'password123',
                'qwerty',
                'abc123'
              ];
              
              console.log('Testing weak password protection...');
              
              for (const password of weakPasswords) {
                try {
                  const response = await this.makeRequest('/api/auth/register', 'POST', {
                    username: 'testuser_' + crypto.randomUUID(),
                    password: password,
                    email: 'test@example.com'
                  });
                  
                  if (response.status === 200) {
                    this.results.push({
                      test: 'weak_password',
                      severity: 'HIGH',
                      passed: false,
                      message: `Weak password "${password}" was accepted`
                    });
                  } else {
                    this.results.push({
                      test: 'weak_password',
                      severity: 'INFO',
                      passed: true,
                      message: `Weak password "${password}" was rejected (status: ${response.status})`
                    });
                  }
                } catch (error) {
                  this.results.push({
                    test: 'weak_password',
                    severity: 'INFO',
                    passed: true,
                    message: `Weak password "${password}" was rejected (error: ${error.message})`
                  });
                }
              }
            }
            
            async testBruteForceProtection() {
              console.log('Testing brute force protection...');
              
              const username = 'testuser_' + crypto.randomUUID();
              const attempts = 10;
              
              for (let i = 0; i < attempts; i++) {
                try {
                  const response = await this.makeRequest('/api/auth/login', 'POST', {
                    username: username,
                    password: 'wrongpassword' + i
                  });
                  
                  if (i > 5 && response.status !== 429) {
                    this.results.push({
                      test: 'brute_force_protection',
                      severity: 'HIGH',
                      passed: false,
                      message: `No rate limiting after ${i} failed attempts`
                    });
                    break;
                  }
                } catch (error) {
                  // Expected for failed attempts
                }
              }
              
              this.results.push({
                test: 'brute_force_protection',
                severity: 'INFO',
                passed: true,
                message: 'Brute force protection appears to be working'
              });
            }
            
            async testJWTSecurity() {
              console.log('Testing JWT security...');
              
              // Test with invalid JWT
              try {
                const response = await this.makeRequest('/api/protected', 'GET', null, {
                  'Authorization': 'Bearer invalid.jwt.token'
                });
                
                if (response.status === 200) {
                  this.results.push({
                    test: 'jwt_validation',
                    severity: 'CRITICAL',
                    passed: false,
                    message: 'Invalid JWT token was accepted'
                  });
                } else {
                  this.results.push({
                    test: 'jwt_validation',
                    severity: 'INFO',
                    passed: true,
                    message: 'Invalid JWT token was rejected'
                  });
                }
              } catch (error) {
                this.results.push({
                  test: 'jwt_validation',
                  severity: 'INFO',
                  passed: true,
                  message: 'JWT validation appears to be working'
                });
              }
              
              // Test with no authorization header
              try {
                const response = await this.makeRequest('/api/protected', 'GET');
                
                if (response.status === 200) {
                  this.results.push({
                    test: 'auth_required',
                    severity: 'HIGH',
                    passed: false,
                    message: 'Protected endpoint accessible without authentication'
                  });
                } else {
                  this.results.push({
                    test: 'auth_required',
                    severity: 'INFO',
                    passed: true,
                    message: 'Protected endpoint requires authentication'
                  });
                }
              } catch (error) {
                this.results.push({
                  test: 'auth_required',
                  severity: 'INFO',
                  passed: true,
                  message: 'Authentication requirement is enforced'
                });
              }
            }
            
            async runAllTests() {
              console.log('Starting authentication security tests...');
              
              await this.testWeakPasswords();
              await this.testBruteForceProtection();
              await this.testJWTSecurity();
              
              return this.results;
            }
            
            generateReport() {
              const criticalIssues = this.results.filter(r => r.severity === 'CRITICAL' && !r.passed);
              const highIssues = this.results.filter(r => r.severity === 'HIGH' && !r.passed);
              const totalTests = this.results.length;
              const passedTests = this.results.filter(r => r.passed).length;
              
              return {
                summary: {
                  totalTests,
                  passedTests,
                  failedTests: totalTests - passedTests,
                  criticalIssues: criticalIssues.length,
                  highIssues: highIssues.length,
                  overallPassed: criticalIssues.length === 0 && highIssues.length === 0
                },
                results: this.results
              };
            }
          }
          
          // Run tests if called directly
          if (require.main === module) {
            const tester = new AuthSecurityTester();
            
            tester.runAllTests().then(() => {
              const report = tester.generateReport();
              const fs = require('fs');
              fs.writeFileSync('auth-security-report.json', JSON.stringify(report, null, 2));
              
              console.log('=== Authentication Security Test Results ===');
              console.log('Total Tests:', report.summary.totalTests);
              console.log('Passed:', report.summary.passedTests);
              console.log('Failed:', report.summary.failedTests);
              console.log('Critical Issues:', report.summary.criticalIssues);
              console.log('High Issues:', report.summary.highIssues);
              console.log('Overall Passed:', report.summary.overallPassed);
              
              if (!report.summary.overallPassed) {
                console.error('Authentication security tests failed!');
                process.exit(1);
              }
            }).catch(error => {
              console.error('Authentication security tests failed:', error);
              process.exit(1);
            });
          }
          
          module.exports = AuthSecurityTester;
          EOF
          
      - name: Start application for auth testing
        run: |
          echo "Starting server for authentication security testing..."
          timeout 120s pnpm dev:server &
          SERVER_PID=$!
          echo "SERVER_PID=$SERVER_PID" >> $GITHUB_ENV
          
          # Wait for server to start
          for i in {1..30}; do
            if curl -s -f http://localhost:3000/health > /dev/null 2>&1; then
              echo "Server is ready!"
              break
            fi
            echo "Waiting for server... ($i/30)"
            sleep 2
          done
          
      - name: Run authentication security tests
        run: |
          cd security-tests/auth
          node auth-tests.js || echo "Authentication tests completed with issues"
          
      - name: Upload auth test results
        uses: actions/upload-artifact@v4
        with:
          name: auth-security-results
          path: security-tests/auth/auth-security-report.json
          retention-days: 30
          
      - name: Cleanup auth testing
        if: always()
        run: |
          if [ ! -z "$SERVER_PID" ]; then
            kill $SERVER_PID 2>/dev/null || true
          fi
          pkill -f "pnpm dev:server" || true
          
  input-validation-testing:
    name: Input Validation Security Testing
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - uses: pnpm/action-setup@v4
        with:
          version: 9
          
      - uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "pnpm"
          
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        
      - name: Create input validation tests
        run: |
          mkdir -p security-tests/validation
          cat > security-tests/validation/validation-tests.js << 'EOF'
          const http = require('http');
          
          class InputValidationTester {
            constructor() {
              this.results = [];
            }
            
            async makeRequest(path, method = 'GET', data = null, headers = {}) {
              return new Promise((resolve, reject) => {
                const options = {
                  hostname: 'localhost',
                  port: 3000,
                  path: path,
                  method: method,
                  headers: {
                    'Content-Type': 'application/json',
                    ...headers
                  }
                };
                
                const req = http.request(options, (res) => {
                  let responseData = '';
                  res.on('data', chunk => responseData += chunk);
                  res.on('end', () => {
                    resolve({ 
                      status: res.statusCode, 
                      headers: res.headers,
                      data: responseData 
                    });
                  });
                });
                
                req.on('error', reject);
                
                if (data) {
                  req.write(JSON.stringify(data));
                }
                
                req.end();
              });
            }
            
            async testSQLInjection() {
              console.log('Testing SQL injection protection...');
              
              const sqlPayloads = [
                "' OR '1'='1",
                "'; DROP TABLE users; --",
                "' UNION SELECT * FROM users --",
                "admin'--",
                "' OR 1=1--"
              ];
              
              for (const payload of sqlPayloads) {
                try {
                  const response = await this.makeRequest('/api/search', 'POST', {
                    query: payload
                  });
                  
                  if (response.status === 200 && response.data.includes('users')) {
                    this.results.push({
                      test: 'sql_injection',
                      severity: 'CRITICAL',
                      passed: false,
                      message: `SQL injection payload "${payload}" may have succeeded`
                    });
                  } else {
                    this.results.push({
                      test: 'sql_injection',
                      severity: 'INFO',
                      passed: true,
                      message: `SQL injection payload "${payload}" was handled safely`
                    });
                  }
                } catch (error) {
                  this.results.push({
                    test: 'sql_injection',
                    severity: 'INFO',
                    passed: true,
                    message: `SQL injection payload "${payload}" was rejected`
                  });
                }
              }
            }
            
            async testXSS() {
              console.log('Testing XSS protection...');
              
              const xssPayloads = [
                '<script>alert("XSS")</script>',
                '<img src=x onerror=alert("XSS")>',
                'javascript:alert("XSS")',
                '<svg onload=alert("XSS")>',
                '<iframe src="javascript:alert(\'XSS\')"></iframe>'
              ];
              
              for (const payload of xssPayloads) {
                try {
                  const response = await this.makeRequest('/api/chat', 'POST', {
                    message: payload
                  });
                  
                  if (response.status === 200 && response.data.includes('<script>')) {
                    this.results.push({
                      test: 'xss_protection',
                      severity: 'HIGH',
                      passed: false,
                      message: `XSS payload "${payload}" was not properly sanitized`
                    });
                  } else {
                    this.results.push({
                      test: 'xss_protection',
                      severity: 'INFO',
                      passed: true,
                      message: `XSS payload "${payload}" was handled safely`
                    });
                  }
                } catch (error) {
                  this.results.push({
                    test: 'xss_protection',
                    severity: 'INFO',
                    passed: true,
                    message: `XSS payload "${payload}" was rejected`
                  });
                }
              }
            }
            
            async testCommandInjection() {
              console.log('Testing command injection protection...');
              
              const commandPayloads = [
                '; ls -la',
                '| cat /etc/passwd',
                '&& whoami',
                '`id`',
                '$(uname -a)'
              ];
              
              for (const payload of commandPayloads) {
                try {
                  const response = await this.makeRequest('/api/execute', 'POST', {
                    command: payload
                  });
                  
                  if (response.status === 200 && (response.data.includes('root') || response.data.includes('bin'))) {
                    this.results.push({
                      test: 'command_injection',
                      severity: 'CRITICAL',
                      passed: false,
                      message: `Command injection payload "${payload}" may have succeeded`
                    });
                  } else {
                    this.results.push({
                      test: 'command_injection',
                      severity: 'INFO',
                      passed: true,
                      message: `Command injection payload "${payload}" was handled safely`
                    });
                  }
                } catch (error) {
                  this.results.push({
                    test: 'command_injection',
                    severity: 'INFO',
                    passed: true,
                    message: `Command injection payload "${payload}" was rejected`
                  });
                }
              }
            }
            
            async testPathTraversal() {
              console.log('Testing path traversal protection...');
              
              const pathPayloads = [
                '../../../etc/passwd',
                '..\\..\\..\\windows\\system32\\config\\sam',
                '....//....//etc/passwd',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd'
              ];
              
              for (const payload of pathPayloads) {
                try {
                  const response = await this.makeRequest('/api/files/' + encodeURIComponent(payload), 'GET');
                  
                  if (response.status === 200 && response.data.includes('root:')) {
                    this.results.push({
                      test: 'path_traversal',
                      severity: 'HIGH',
                      passed: false,
                      message: `Path traversal payload "${payload}" succeeded`
                    });
                  } else {
                    this.results.push({
                      test: 'path_traversal',
                      severity: 'INFO',
                      passed: true,
                      message: `Path traversal payload "${payload}" was blocked`
                    });
                  }
                } catch (error) {
                  this.results.push({
                    test: 'path_traversal',
                    severity: 'INFO',
                    passed: true,
                    message: `Path traversal payload "${payload}" was rejected`
                  });
                }
              }
            }
            
            async runAllTests() {
              console.log('Starting input validation security tests...');
              
              await this.testSQLInjection();
              await this.testXSS();
              await this.testCommandInjection();
              await this.testPathTraversal();
              
              return this.results;
            }
            
            generateReport() {
              const criticalIssues = this.results.filter(r => r.severity === 'CRITICAL' && !r.passed);
              const highIssues = this.results.filter(r => r.severity === 'HIGH' && !r.passed);
              const totalTests = this.results.length;
              const passedTests = this.results.filter(r => r.passed).length;
              
              return {
                summary: {
                  totalTests,
                  passedTests,
                  failedTests: totalTests - passedTests,
                  criticalIssues: criticalIssues.length,
                  highIssues: highIssues.length,
                  overallPassed: criticalIssues.length === 0 && highIssues.length === 0
                },
                results: this.results
              };
            }
          }
          
          // Run tests if called directly
          if (require.main === module) {
            const tester = new InputValidationTester();
            
            tester.runAllTests().then(() => {
              const report = tester.generateReport();
              const fs = require('fs');
              fs.writeFileSync('validation-security-report.json', JSON.stringify(report, null, 2));
              
              console.log('=== Input Validation Security Test Results ===');
              console.log('Total Tests:', report.summary.totalTests);
              console.log('Passed:', report.summary.passedTests);
              console.log('Failed:', report.summary.failedTests);
              console.log('Critical Issues:', report.summary.criticalIssues);
              console.log('High Issues:', report.summary.highIssues);
              console.log('Overall Passed:', report.summary.overallPassed);
              
              if (!report.summary.overallPassed) {
                console.error('Input validation security tests failed!');
                process.exit(1);
              }
            }).catch(error => {
              console.error('Input validation security tests failed:', error);
              process.exit(1);
            });
          }
          
          module.exports = InputValidationTester;
          EOF
          
      - name: Start application for validation testing
        run: |
          echo "Starting server for input validation security testing..."
          timeout 120s pnpm dev:server &
          SERVER_PID=$!
          echo "SERVER_PID=$SERVER_PID" >> $GITHUB_ENV
          
          # Wait for server to start
          for i in {1..30}; do
            if curl -s -f http://localhost:3000/health > /dev/null 2>&1; then
              echo "Server is ready!"
              break
            fi
            echo "Waiting for server... ($i/30)"
            sleep 2
          done
          
      - name: Run input validation security tests
        run: |
          cd security-tests/validation
          node validation-tests.js || echo "Validation tests completed with issues"
          
      - name: Upload validation test results
        uses: actions/upload-artifact@v4
        with:
          name: validation-security-results
          path: security-tests/validation/validation-security-report.json
          retention-days: 30
          
      - name: Cleanup validation testing
        if: always()
        run: |
          if [ ! -z "$SERVER_PID" ]; then
            kill $SERVER_PID 2>/dev/null || true
          fi
          pkill -f "pnpm dev:server" || true
          
  rate-limiting-testing:
    name: Rate Limiting Security Testing
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - uses: pnpm/action-setup@v4
        with:
          version: 9
          
      - uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "pnpm"
          
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        
      - name: Create rate limiting tests
        run: |
          mkdir -p security-tests/rate-limit
          cat > security-tests/rate-limit/rate-limit-tests.js << 'EOF'
          const http = require('http');
          
          class RateLimitTester {
            constructor() {
              this.results = [];
            }
            
            async makeRequest(path, method = 'GET', data = null, headers = {}) {
              return new Promise((resolve, reject) => {
                const options = {
                  hostname: 'localhost',
                  port: 3000,
                  path: path,
                  method: method,
                  headers: {
                    'Content-Type': 'application/json',
                    ...headers
                  }
                };
                
                const req = http.request(options, (res) => {
                  let responseData = '';
                  res.on('data', chunk => responseData += chunk);
                  res.on('end', () => {
                    resolve({ 
                      status: res.statusCode, 
                      headers: res.headers,
                      data: responseData 
                    });
                  });
                });
                
                req.on('error', reject);
                
                if (data) {
                  req.write(JSON.stringify(data));
                }
                
                req.end();
              });
            }
            
            async testRateLimiting() {
              console.log('Testing rate limiting protection...');
              
              const endpoints = [
                '/api/chat',
                '/api/search',
                '/health'
              ];
              
              for (const endpoint of endpoints) {
                console.log(`Testing rate limiting on ${endpoint}...`);
                
                let rateLimitTriggered = false;
                
                // Make rapid requests to trigger rate limiting
                for (let i = 0; i < 50; i++) {
                  try {
                    const response = await this.makeRequest(endpoint, 'GET');
                    
                    if (response.status === 429) {
                      rateLimitTriggered = true;
                      this.results.push({
                        test: 'rate_limiting',
                        endpoint: endpoint,
                        severity: 'INFO',
                        passed: true,
                        message: `Rate limiting triggered on ${endpoint} after ${i + 1} requests`
                      });
                      break;
                    }
                    
                    // Small delay to not overwhelm completely
                    await new Promise(resolve => setTimeout(resolve, 50));
                  } catch (error) {
                    // Network errors are expected under load
                  }
                }
                
                if (!rateLimitTriggered) {
                  this.results.push({
                    test: 'rate_limiting',
                    endpoint: endpoint,
                    severity: 'MEDIUM',
                    passed: false,
                    message: `No rate limiting detected on ${endpoint} after 50 requests`
                  });
                }
              }
            }
            
            async testCSRFProtection() {
              console.log('Testing CSRF protection...');
              
              // Test POST request without proper headers
              try {
                const response = await this.makeRequest('/api/chat', 'POST', {
                  message: 'test message'
                }, {
                  'Origin': 'http://malicious-site.com',
                  'Referer': 'http://malicious-site.com/attack.html'
                });
                
                if (response.status === 200) {
                  this.results.push({
                    test: 'csrf_protection',
                    severity: 'HIGH',
                    passed: false,
                    message: 'CSRF protection may be missing - cross-origin request succeeded'
                  });
                } else {
                  this.results.push({
                    test: 'csrf_protection',
                    severity: 'INFO',
                    passed: true,
                    message: 'CSRF protection appears to be working'
                  });
                }
              } catch (error) {
                this.results.push({
                  test: 'csrf_protection',
                  severity: 'INFO',
                  passed: true,
                  message: 'CSRF protection appears to be working'
                });
              }
            }
            
            async runAllTests() {
              console.log('Starting rate limiting security tests...');
              
              await this.testRateLimiting();
              await this.testCSRFProtection();
              
              return this.results;
            }
            
            generateReport() {
              const criticalIssues = this.results.filter(r => r.severity === 'CRITICAL' && !r.passed);
              const highIssues = this.results.filter(r => r.severity === 'HIGH' && !r.passed);
              const mediumIssues = this.results.filter(r => r.severity === 'MEDIUM' && !r.passed);
              const totalTests = this.results.length;
              const passedTests = this.results.filter(r => r.passed).length;
              
              return {
                summary: {
                  totalTests,
                  passedTests,
                  failedTests: totalTests - passedTests,
                  criticalIssues: criticalIssues.length,
                  highIssues: highIssues.length,
                  mediumIssues: mediumIssues.length,
                  overallPassed: criticalIssues.length === 0 && highIssues.length === 0
                },
                results: this.results
              };
            }
          }
          
          // Run tests if called directly
          if (require.main === module) {
            const tester = new RateLimitTester();
            
            tester.runAllTests().then(() => {
              const report = tester.generateReport();
              const fs = require('fs');
              fs.writeFileSync('rate-limit-security-report.json', JSON.stringify(report, null, 2));
              
              console.log('=== Rate Limiting Security Test Results ===');
              console.log('Total Tests:', report.summary.totalTests);
              console.log('Passed:', report.summary.passedTests);
              console.log('Failed:', report.summary.failedTests);
              console.log('Critical Issues:', report.summary.criticalIssues);
              console.log('High Issues:', report.summary.highIssues);
              console.log('Medium Issues:', report.summary.mediumIssues);
              console.log('Overall Passed:', report.summary.overallPassed);
              
              if (!report.summary.overallPassed) {
                console.error('Rate limiting security tests failed!');
                process.exit(1);
              }
            }).catch(error => {
              console.error('Rate limiting security tests failed:', error);
              process.exit(1);
            });
          }
          
          module.exports = RateLimitTester;
          EOF
          
      - name: Start application for rate limit testing
        run: |
          echo "Starting server for rate limiting security testing..."
          timeout 180s pnpm dev:server &
          SERVER_PID=$!
          echo "SERVER_PID=$SERVER_PID" >> $GITHUB_ENV
          
          # Wait for server to start
          for i in {1..30}; do
            if curl -s -f http://localhost:3000/health > /dev/null 2>&1; then
              echo "Server is ready!"
              break
            fi
            echo "Waiting for server... ($i/30)"
            sleep 2
          done
          
      - name: Run rate limiting security tests
        run: |
          cd security-tests/rate-limit
          node rate-limit-tests.js || echo "Rate limiting tests completed with issues"
          
      - name: Upload rate limit test results
        uses: actions/upload-artifact@v4
        with:
          name: rate-limit-security-results
          path: security-tests/rate-limit/rate-limit-security-report.json
          retention-days: 30
          
      - name: Cleanup rate limit testing
        if: always()
        run: |
          if [ ! -z "$SERVER_PID" ]; then
            kill $SERVER_PID 2>/dev/null || true
          fi
          pkill -f "pnpm dev:server" || true
          
  security-summary:
    name: Security Testing Summary
    runs-on: ubuntu-latest
    needs: [authentication-testing, input-validation-testing, rate-limiting-testing]
    if: always()
    
    steps:
      - name: Download all security test results
        uses: actions/download-artifact@v4
        with:
          path: security-results
          
      - name: Generate security summary report
        run: |
          echo "Generating security summary report..."
          
          node -e "
            const fs = require('fs');
            const path = require('path');
            
            const reportDirs = ['auth-security-results', 'validation-security-results', 'rate-limit-security-results'];
            const allResults = [];
            
            reportDirs.forEach(dir => {
              const dirPath = path.join('security-results', dir);
              if (fs.existsSync(dirPath)) {
                const files = fs.readdirSync(dirPath);
                files.forEach(file => {
                  if (file.endsWith('.json')) {
                    try {
                      const content = JSON.parse(fs.readFileSync(path.join(dirPath, file), 'utf8'));
                      allResults.push({
                        category: dir.replace('-results', ''),
                        ...content
                      });
                    } catch (error) {
                      console.error('Error reading', file, ':', error.message);
                    }
                  }
                });
              }
            });
            
            let totalTests = 0;
            let totalPassed = 0;
            let totalCritical = 0;
            let totalHigh = 0;
            let totalMedium = 0;
            
            let summaryReport = '# Security Testing Summary Report\n\n';
            summaryReport += '## Overall Results\n\n';
            
            allResults.forEach(result => {
              if (result.summary) {
                totalTests += result.summary.totalTests || 0;
                totalPassed += result.summary.passedTests || 0;
                totalCritical += result.summary.criticalIssues || 0;
                totalHigh += result.summary.highIssues || 0;
                totalMedium += result.summary.mediumIssues || 0;
                
                summaryReport += '### ' + result.category.replace('-', ' ').toUpperCase() + '\n';
                summaryReport += '- Tests: ' + (result.summary.totalTests || 0) + '\n';
                summaryReport += '- Passed: ' + (result.summary.passedTests || 0) + '\n';
                summaryReport += '- Critical Issues: ' + (result.summary.criticalIssues || 0) + '\n';
                summaryReport += '- High Issues: ' + (result.summary.highIssues || 0) + '\n';
                summaryReport += '- Medium Issues: ' + (result.summary.mediumIssues || 0) + '\n\n';
              }
            });
            
            summaryReport += '## Summary\n';
            summaryReport += '- **Total Tests**: ' + totalTests + '\n';
            summaryReport += '- **Passed**: ' + totalPassed + '\n';
            summaryReport += '- **Failed**: ' + (totalTests - totalPassed) + '\n';
            summaryReport += '- **Critical Issues**: ' + totalCritical + '\n';
            summaryReport += '- **High Issues**: ' + totalHigh + '\n';
            summaryReport += '- **Medium Issues**: ' + totalMedium + '\n\n';
            
            if (totalCritical > 0) {
              summaryReport += '## ðŸš¨ CRITICAL SECURITY ISSUES FOUND\n\n';
              summaryReport += 'Critical security vulnerabilities have been detected. These must be addressed immediately before deployment.\n\n';
            } else if (totalHigh > 0) {
              summaryReport += '## âš ï¸ HIGH PRIORITY SECURITY ISSUES\n\n';
              summaryReport += 'High priority security issues have been detected. These should be addressed before deployment.\n\n';
            } else {
              summaryReport += '## âœ… SECURITY TESTS PASSED\n\n';
              summaryReport += 'All security tests passed successfully. The application appears to have good security practices.\n\n';
            }
            
            summaryReport += '## Recommendations\n';
            summaryReport += '- Review all failed security tests\n';
            summaryReport += '- Implement fixes for critical and high priority issues\n';
            summaryReport += '- Consider additional security measures for medium priority issues\n';
            summaryReport += '- Run security tests regularly as part of CI/CD pipeline\n';
            summaryReport += '- Consider penetration testing for production deployment\n\n';
            
            summaryReport += '---\n';
            summaryReport += '*Generated by automated security testing workflow*\n';
            
            fs.writeFileSync('security-summary-report.md', summaryReport);
            
            console.log('Security Summary Report Generated');
            console.log('Total Tests:', totalTests);
            console.log('Passed:', totalPassed);
            console.log('Critical Issues:', totalCritical);
            console.log('High Issues:', totalHigh);
            console.log('Medium Issues:', totalMedium);
            
            // Exit with error if critical issues found
            if (totalCritical > 0) {
              console.error('CRITICAL SECURITY ISSUES DETECTED!');
              process.exit(1);
            }
          "
          
      - name: Upload security summary report
        uses: actions/upload-artifact@v4
        with:
          name: security-summary-report
          path: security-summary-report.md
          retention-days: 90
          
      - name: Comment security results on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            try {
              const report = fs.readFileSync('security-summary-report.md', 'utf8');
              
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `## ðŸ”’ Security Testing Results
                
                ${report}
                
                ðŸ“‹ Full security test results are available in the workflow artifacts.`
              });
            } catch (error) {
              console.log('Failed to comment security results:', error.message);
            }